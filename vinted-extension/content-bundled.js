// ==========================================
// VINTED CONTENT SCRIPT - BUNDLED VERSION
// Auto-generated by build-content.js
// Do not edit this file directly - edit files in content/ directory
// ==========================================

(function() {
  'use strict';
  
  // ==========================================
  // config.js
  // ==========================================
  
  // ==================== CONFIG ====================
  const CONFIG = {
    DEFAULT_BRAND_ID: "362",
    POLL_INTERVAL: 3000, // 3 secondes pour les items
    MAX_ITEMS: 200,
    STORAGE_KEY: "vinted_saved_filters",
    ALERTS_STORAGE_KEY: "vinted_alerts",
    DARK_MODE_KEY: "vinted_dark_mode",
    BUY_BUTTON_KEY: "vinted_buy_button_enabled",
    MESSAGES_REFRESH_INTERVAL: 10000, // 10 secondes pour les messages
    NOTIFICATIONS_REFRESH_INTERVAL: 10000, // 10 secondes pour les notifications
  };
  
  const state = {
    seenIds: new Set(),
    items: [],
    isPolling: false,
    pollInterval: null,
    savedFilters: [],
    alerts: [],
    darkMode: false,
    buyButtonEnabled: true,
  };

  // ==========================================
  // utils.js
  // ==========================================
  
  // ==================== UTILS ====================
  function escapeHtml(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }
  
  function formatPrice(item) {
    const amount = item.price?.amount || item.price?.value || item.price || 0;
    const currency = item.price?.currency || item.price?.currency_code || "EUR";
    return new Intl.NumberFormat("fr-FR", {
      style: "currency",
      currency: currency,
    }).format(amount);
  }
  
  function formatTime(date) {
    return new Intl.DateTimeFormat("fr-FR", {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
    }).format(date);
  }
  
  function extractSize(item) {
    const sizeLabel =
      item.size_title ||
      item.size?.localized_title ||
      item.size?.title ||
      item.size?.brand_size;
  
    if (!sizeLabel) return null;
  
    return sizeLabel
      .replace(/^(taille|size)\s+/i, "")
      .replace(/\b(taille unique|unique size)\b/i, "TU")
      .split(/[\s,/|-]+/)[0]
      ?.toUpperCase();
  }
  
  function extractCondition(item) {
    if (typeof item.condition === "string") return item.condition;
    return (
      item.condition?.translated_title ||
      item.condition?.title ||
      item.condition_title ||
      item.status ||
      null
    );
  }

  // ==========================================
  // darkMode.js
  // ==========================================
  
  // ==================== DARK MODE ====================
  // Variable pour √©viter les initialisations multiples
  let darkModeInitialized = false;
  let darkModeObserverStarted = false;
  
  async function loadDarkMode() {
    // √âviter les initialisations multiples de l'observer
    if (darkModeObserverStarted) {
      return;
    }
    
    try {
      // Toujours charger depuis le storage pour avoir la valeur la plus r√©cente
      // M√™me si l'IIFE a d√©j√† fait le travail visuel, on veut s'assurer que state.darkMode est √† jour
      const result = await chrome.storage.local.get(CONFIG.DARK_MODE_KEY);
      state.darkMode = result[CONFIG.DARK_MODE_KEY] || false;
      
      // Appliquer le mode nuit (au cas o√π l'IIFE ne l'aurait pas fait ou aurait √©chou√©)
      applyDarkMode();
      ensureDarkModeApplied();
      
      // IMPORTANT: Toujours d√©marrer l'observer, m√™me si darkModeInitialized est d√©j√† true
      // L'IIFE ne d√©marre pas l'observer, donc on doit toujours le faire ici
      if (!darkModeObserverStarted) {
        startDarkModeObserver();
        darkModeObserverStarted = true;
      }
    } catch (error) {
      console.error("[Dark Mode] Erreur lors du chargement:", error);
      // M√™me en cas d'erreur, essayer de d√©marrer l'observer si le mode nuit √©tait d√©j√† activ√©
      if (!darkModeObserverStarted && state.darkMode) {
        startDarkModeObserver();
        darkModeObserverStarted = true;
      }
    }
  }
  
  async function toggleDarkMode() {
    state.darkMode = !state.darkMode;
    await chrome.storage.local.set({ [CONFIG.DARK_MODE_KEY]: state.darkMode });
    applyDarkMode();
    ensureDarkModeApplied();
    updateDarkModeButton();
  }
  
  function applyDarkMode() {
    if (state.darkMode) {
      document.documentElement.classList.add('vinted-dark-mode');
    } else {
      document.documentElement.classList.remove('vinted-dark-mode');
    }
  }
  
  // S'assurer que le mode nuit reste appliqu√© m√™me apr√®s des changements DOM
  function ensureDarkModeApplied() {
    if (state.darkMode) {
      // Forcer l'application imm√©diate
      if (!document.documentElement.classList.contains('vinted-dark-mode')) {
        document.documentElement.classList.add('vinted-dark-mode');
      }
    } else {
      document.documentElement.classList.remove('vinted-dark-mode');
    }
  }
  
  // Appliquer le mode nuit imm√©diatement au chargement (avant m√™me que le DOM soit pr√™t)
  // Cela garantit qu'il s'applique d√®s le d√©but, m√™me si le script se charge tard
  // Note: Cette initialisation rapide applique seulement l'√©tat visuel.
  // L'initialisation compl√®te avec l'observer est g√©r√©e par loadDarkMode()
  // IMPORTANT: Cette IIFE ne doit PAS emp√™cher loadDarkMode() de d√©marrer l'observer
  (async () => {
    // Utiliser un flag s√©par√© pour √©viter les conflits avec loadDarkMode()
    // darkModeInitialized indique seulement que l'√©tat visuel initial a √©t√© appliqu√©
    if (darkModeInitialized) return;
    
    try {
      const result = await chrome.storage.local.get(CONFIG.DARK_MODE_KEY);
      const darkModeEnabled = result[CONFIG.DARK_MODE_KEY] || false;
      state.darkMode = darkModeEnabled;
      if (darkModeEnabled && document.documentElement) {
        document.documentElement.classList.add('vinted-dark-mode');
      }
      // Marquer seulement que l'√©tat visuel initial a √©t√© appliqu√©
      // Cela n'emp√™che pas loadDarkMode() de d√©marrer l'observer
      darkModeInitialized = true;
      // Note: On ne d√©marre JAMAIS l'observer ici car loadDarkMode() doit toujours le faire
      // L'observer est critique pour maintenir le mode nuit, donc il doit √™tre d√©marr√© par loadDarkMode()
    } catch (error) {
      console.error("[Dark Mode] Erreur lors du chargement initial:", error);
      // En cas d'erreur, ne pas d√©finir darkModeInitialized pour que loadDarkMode() puisse r√©essayer
    }
  })();
  
  // Observer pour maintenir le mode nuit
  let darkModeObserver = null;
  let darkModeCheckInterval = null;
  
  function startDarkModeObserver() {
    // Nettoyer l'interval existant s'il y en a un
    if (darkModeCheckInterval) {
      clearInterval(darkModeCheckInterval);
      darkModeCheckInterval = null;
    }
    
    if (darkModeObserver) return;
    
    // Observer les changements de classe sur documentElement
    darkModeObserver = new MutationObserver((mutations) => {
      // Si la classe vinted-dark-mode est retir√©e et que le mode nuit est activ√©, la remettre
      if (state.darkMode && !document.documentElement.classList.contains('vinted-dark-mode')) {
        document.documentElement.classList.add('vinted-dark-mode');
      }
    });
    
    darkModeObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class']
    });
    
    // V√©rification p√©riodique pour s'assurer que le mode nuit reste appliqu√©
    // Utile si d'autres scripts modifient le DOM (v√©rification moins fr√©quente pour √©viter le lag)
    darkModeCheckInterval = setInterval(() => {
      if (state.darkMode) {
        ensureDarkModeApplied();
      }
    }, 5000); // V√©rifier toutes les 5 secondes (au lieu d'1 seconde)
  }
  
  function stopDarkModeObserver() {
    if (darkModeObserver) {
      darkModeObserver.disconnect();
      darkModeObserver = null;
    }
    if (darkModeCheckInterval) {
      clearInterval(darkModeCheckInterval);
      darkModeCheckInterval = null;
    }
  }
  
  function updateDarkModeButton() {
    const btn = document.getElementById('dark-mode-toggle');
    if (btn) {
      btn.textContent = state.darkMode ? '‚òÄÔ∏è' : 'üåô';
      btn.title = state.darkMode ? 'Mode clair' : 'Mode sombre';
    }
  }

  // ==========================================
  // wallet.js
  // ==========================================
  
  // ==================== WALLET BALANCE ====================
  let cachedWalletInboxData = null;
  let cachedWalletInboxTime = 0;
  const WALLET_INBOX_CACHE_DURATION = 5000; // 5 secondes de cache
  
  async function getUserId() {
    // Utiliser le cache global si disponible (partag√© avec offer.js)
    if (window.cachedGlobalUserId) {
      return window.cachedGlobalUserId;
    }
    
    // M√©thode 1: Essayer de r√©cup√©rer depuis la page actuelle
    try {
      const scripts = document.querySelectorAll('script:not([src])');
      for (const script of scripts) {
        const content = script.textContent || '';
        const patterns = [
          /"user_id"\s*:\s*(\d+)/,
          /"id"\s*:\s*(\d+).*"login"/,
          /"current_user_id"\s*:\s*(\d+)/,
          /userId["\s]*[:=]\s*["']?(\d+)/i,
        ];
        
        for (const pattern of patterns) {
          const match = content.match(pattern);
          if (match && match[1]) {
            const userId = String(match[1]);
            console.log("[Wallet] User ID trouv√© depuis la page:", userId);
            window.cachedGlobalUserId = userId;
            return userId;
          }
        }
      }
    } catch (error) {
      console.warn("[Wallet] Erreur lors de l'extraction du userId depuis la page:", error);
    }
    
    // M√©thode 2: Essayer depuis les cookies
    try {
      const cookies = document.cookie.split(';');
      for (const cookie of cookies) {
        const [name, value] = cookie.trim().split('=');
        if (name === 'user_id' || name === 'userId') {
          if (value) {
            console.log("[Wallet] User ID trouv√© depuis les cookies:", value);
            window.cachedGlobalUserId = value;
            return value;
          }
        }
      }
    } catch (error) {
      console.warn("[Wallet] Erreur lors de la r√©cup√©ration du userId depuis les cookies:", error);
    }
    
    // M√©thode 3: Utiliser l'inbox SANS charger les conversations individuelles
    try {
      const response = await fetch('https://www.vinted.fr/api/v2/inbox?page=1&per_page=20', {
        credentials: 'include',
        headers: {
          'accept': 'application/json, text/plain, */*',
          'accept-language': 'fr',
        }
      });
  
      if (response.ok) {
        const data = await response.json();
        // Mettre en cache
        cachedWalletInboxData = data;
        cachedWalletInboxTime = Date.now();
        
        // Chercher le userId dans les donn√©es de l'inbox sans charger les conversations
        if (data.conversations && data.conversations.length > 0) {
          for (const conversation of data.conversations) {
            if (conversation.last_message && conversation.last_message.user_id) {
              const userId = String(conversation.last_message.user_id);
              console.log("[Wallet] User ID trouv√© via inbox (last_message):", userId);
              window.cachedGlobalUserId = userId;
              return userId;
            }
          }
        }
      }
    } catch (error) {
      console.error("[Wallet] Erreur lors de la r√©cup√©ration via API inbox:", error);
    }
    
    // Dernier recours: NE PAS charger les conversations individuelles
    console.warn("[Wallet] User ID non trouv√© - les conversations individuelles ne seront PAS charg√©es");
    return null;
  }
  
  async function fetchWalletBalance() {
    const userId = await getUserId();
    if (!userId) {
      console.warn("[Wallet] User ID non trouv√©");
      return null;
    }
  
    try {
      const response = await fetch(`https://www.vinted.fr/api/v2/users/${userId}/balance`, {
        method: 'GET',
        credentials: 'include',
        headers: {
          'accept': 'application/json, text/plain, */*',
        }
      });
  
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
  
      const data = await response.json();
      if (data.user_balance) {
        return {
          available: parseFloat(data.user_balance.available_amount?.amount || data.user_balance.available_amount || 0) || 0,
          escrow: parseFloat(data.user_balance.escrow_amount?.amount || data.user_balance.escrow_amount || 0) || 0,
          currency: data.user_balance.available_amount?.currency_code || data.user_balance.currency || 'EUR'
        };
      }
      return null;
    } catch (error) {
      console.error("[Wallet] Erreur lors de la r√©cup√©ration du solde:", error);
      return null;
    }
  }
  
  function formatBalance(amount, currency = 'EUR') {
    return new Intl.NumberFormat('fr-FR', {
      style: 'currency',
      currency: currency,
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(amount);
  }
  
  function updateWalletDisplay(balance) {
    const walletDisplay = document.getElementById('vinted-wallet-balance');
    if (!walletDisplay) return;
  
    if (balance) {
      const availableText = formatBalance(balance.available, balance.currency);
      const escrowText = formatBalance(balance.escrow, balance.currency);
      
      // Afficher le solde disponible et le montant √† venir
      if (balance.escrow > 0) {
        walletDisplay.textContent = `${availableText} (+ ${escrowText})`;
        walletDisplay.title = `Solde disponible: ${availableText} | Montant √† venir: ${escrowText}`;
      } else {
        walletDisplay.textContent = availableText;
        walletDisplay.title = `Solde disponible: ${availableText}`;
      }
    } else {
      walletDisplay.textContent = '--';
      walletDisplay.title = 'Solde non disponible';
    }
  }
  
  async function loadWalletBalance() {
    const balance = await fetchWalletBalance();
    updateWalletDisplay(balance);
    // Ne pas appeler initOfferCount ici car il est d√©j√† appel√© dans ui.js
    // pour √©viter les appels en double
    return balance;
  }

  // ==========================================
  // settings.js
  // ==========================================
  
  // ==================== SETTINGS MANAGER ====================
  const SETTINGS_STORAGE_KEY = "vinted_refresh_intervals";
  
  // Valeurs par d√©faut
  const DEFAULT_INTERVALS = {
    messages: 10000,      // 10 secondes
    notifications: 10000,  // 10 secondes
    items: 3000           // 3 secondes
  };
  
  // Charger les intervalles depuis le storage
  async function loadIntervals() {
    return new Promise((resolve) => {
      chrome.storage.local.get([SETTINGS_STORAGE_KEY], (result) => {
        const saved = result[SETTINGS_STORAGE_KEY];
        resolve(saved || DEFAULT_INTERVALS);
      });
    });
  }
  
  // Sauvegarder les intervalles
  async function saveIntervals(intervals) {
    return new Promise((resolve) => {
      chrome.storage.local.set({ [SETTINGS_STORAGE_KEY]: intervals }, () => {
        resolve();
      });
    });
  }
  
  // Obtenir l'intervalle actuel pour un type
  async function getInterval(type) {
    const intervals = await loadIntervals();
    return intervals[type] || DEFAULT_INTERVALS[type];
  }
  
  // Cr√©er le bouton de param√®tres
  function createSettingsButton() {
    const walletDisplay = document.getElementById('vinted-wallet-balance');
    if (!walletDisplay) {
      setTimeout(createSettingsButton, 500);
      return;
    }
  
    // V√©rifier si le bouton existe d√©j√†
    if (document.getElementById('vinted-settings-button')) {
      return;
    }
  
    const settingsButton = document.createElement('button');
    settingsButton.id = 'vinted-settings-button';
    settingsButton.className = 'vinted-settings-button';
    settingsButton.innerHTML = `
      <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
      </svg>
    `;
    settingsButton.title = 'Param√®tres de rafra√Æchissement';
    settingsButton.addEventListener('click', () => {
      openSettingsModal();
    });
  
    // Ins√©rer apr√®s le wallet
    const walletParent = walletDisplay.parentElement;
    if (walletParent) {
      walletParent.insertBefore(settingsButton, walletDisplay.nextSibling);
    }
  }
  
  // Ouvrir la modal de param√®tres
  async function openSettingsModal() {
    // V√©rifier si la modal existe d√©j√†
    const existingModal = document.getElementById('vinted-settings-modal');
    if (existingModal) {
      existingModal.style.display = 'flex';
      return;
    }
  
    const intervals = await loadIntervals();
  
    const modal = document.createElement('div');
    modal.id = 'vinted-settings-modal';
    modal.className = 'vinted-settings-modal';
    modal.innerHTML = `
      <div class="vinted-settings-container">
        <div class="vinted-settings-header">
          <h2>Param√®tres de rafra√Æchissement</h2>
          <button class="vinted-settings-close" aria-label="Fermer">√ó</button>
        </div>
        <div class="vinted-settings-content">
          <div class="vinted-settings-section">
            <label for="messages-interval">
              <span class="settings-label">Messages</span>
              <span class="settings-description">Intervalle de rafra√Æchissement des messages</span>
            </label>
            <div class="settings-input-group">
              <input type="number" 
                     id="messages-interval" 
                     class="settings-interval-input" 
                     min="1000" 
                     step="1000" 
                     value="${intervals.messages}">
              <span class="settings-unit">ms</span>
              <span class="settings-display">(${intervals.messages / 1000}s)</span>
            </div>
          </div>
  
          <div class="vinted-settings-section">
            <label for="notifications-interval">
              <span class="settings-label">Notifications</span>
              <span class="settings-description">Intervalle de rafra√Æchissement des notifications</span>
            </label>
            <div class="settings-input-group">
              <input type="number" 
                     id="notifications-interval" 
                     class="settings-interval-input" 
                     min="1000" 
                     step="1000" 
                     value="${intervals.notifications}">
              <span class="settings-unit">ms</span>
              <span class="settings-display">(${intervals.notifications / 1000}s)</span>
            </div>
          </div>
  
          <div class="vinted-settings-section">
            <label for="items-interval">
              <span class="settings-label">Articles</span>
              <span class="settings-description">Intervalle de rafra√Æchissement des articles</span>
            </label>
            <div class="settings-input-group">
              <input type="number" 
                     id="items-interval" 
                     class="settings-interval-input" 
                     min="1000" 
                     step="1000" 
                     value="${intervals.items}">
              <span class="settings-unit">ms</span>
              <span class="settings-display">(${intervals.items / 1000}s)</span>
            </div>
          </div>
  
          <div class="vinted-settings-actions">
            <button class="settings-btn settings-btn-reset" id="settings-reset-btn">R√©initialiser</button>
            <button class="settings-btn settings-btn-save" id="settings-save-btn">Enregistrer</button>
          </div>
        </div>
      </div>
    `;
  
    document.body.appendChild(modal);
  
    // Mettre √† jour l'affichage en temps r√©el
    const inputs = modal.querySelectorAll('.settings-interval-input');
    inputs.forEach(input => {
      input.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        const display = e.target.parentElement.querySelector('.settings-display');
        if (display) {
          display.textContent = `(${value / 1000}s)`;
        }
      });
    });
  
    // Bouton de r√©initialisation
    const resetBtn = modal.querySelector('#settings-reset-btn');
    resetBtn.addEventListener('click', () => {
      document.getElementById('messages-interval').value = DEFAULT_INTERVALS.messages;
      document.getElementById('notifications-interval').value = DEFAULT_INTERVALS.notifications;
      document.getElementById('items-interval').value = DEFAULT_INTERVALS.items;
      
      // Mettre √† jour les affichages
      inputs.forEach(input => {
        const value = parseInt(input.value);
        const display = input.parentElement.querySelector('.settings-display');
        if (display) {
          display.textContent = `(${value / 1000}s)`;
        }
      });
    });
  
    // Bouton de sauvegarde
    const saveBtn = modal.querySelector('#settings-save-btn');
    saveBtn.addEventListener('click', async () => {
      const newIntervals = {
        messages: parseInt(document.getElementById('messages-interval').value),
        notifications: parseInt(document.getElementById('notifications-interval').value),
        items: parseInt(document.getElementById('items-interval').value)
      };
  
      // Validation
      if (newIntervals.messages < 1000 || newIntervals.notifications < 1000 || newIntervals.items < 1000) {
        alert('Les intervalles doivent √™tre d\'au moins 1000ms (1 seconde)');
        return;
      }
  
      await saveIntervals(newIntervals);
      
      // Mettre √† jour la config
      if (typeof CONFIG !== 'undefined') {
        CONFIG.MESSAGES_REFRESH_INTERVAL = newIntervals.messages;
        CONFIG.NOTIFICATIONS_REFRESH_INTERVAL = newIntervals.notifications;
        CONFIG.POLL_INTERVAL = newIntervals.items;
      }
  
      // Red√©marrer les intervalles avec les nouveaux timings
      if (typeof startMessagesAutoRefresh === 'function' && typeof stopMessagesAutoRefresh === 'function') {
        stopMessagesAutoRefresh();
        setTimeout(async () => {
          await startMessagesAutoRefresh();
        }, 100);
      }
  
      if (typeof refreshNotificationsWidget === 'function') {
        if (typeof stopNotificationsWidgetRefresh === 'function') {
          stopNotificationsWidgetRefresh();
        }
        setTimeout(() => {
          if (typeof createNotificationsWidget === 'function') {
            // Le widget red√©marrera automatiquement son intervalle
          }
        }, 100);
      }
  
      if (typeof stopMonitor === 'function' && typeof startMonitor === 'function' && state.isPolling) {
        stopMonitor();
        setTimeout(() => {
          startMonitor();
        }, 100);
      }
  
      // Fermer la modal
      closeSettingsModal();
      
      console.log('[Settings] Intervalles mis √† jour:', newIntervals);
    });
  
    // Fermer la modal
    const closeBtn = modal.querySelector('.vinted-settings-close');
    closeBtn.addEventListener('click', closeSettingsModal);
    
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeSettingsModal();
      }
    });
  
    // Fermer avec Escape
    const escapeHandler = (e) => {
      if (e.key === 'Escape') {
        closeSettingsModal();
        document.removeEventListener('keydown', escapeHandler);
      }
    };
    document.addEventListener('keydown', escapeHandler);
  }
  
  function closeSettingsModal() {
    const modal = document.getElementById('vinted-settings-modal');
    if (modal) {
      modal.style.display = 'none';
    }
  }
  
  // Initialiser les intervalles au chargement
  async function initIntervals() {
    const intervals = await loadIntervals();
    
    // Mettre √† jour la config
    if (typeof CONFIG !== 'undefined') {
      CONFIG.MESSAGES_REFRESH_INTERVAL = intervals.messages;
      CONFIG.NOTIFICATIONS_REFRESH_INTERVAL = intervals.notifications;
      CONFIG.POLL_INTERVAL = intervals.items;
    }
  }
  
  // Exporter pour utilisation globale
  if (typeof window !== 'undefined') {
    window.getInterval = getInterval;
    window.loadIntervals = loadIntervals;
    window.saveIntervals = saveIntervals;
  }
  
  

  // ==========================================
  // sidebarTabs.js
  // ==========================================
  
  // ==================== SIDEBAR TABS SYSTEM ====================
  let activeTab = 'messages'; // Par d√©faut sur les messages
  
  function createSidebarTabs() {
    const sidebarStickyContainer = document.getElementById('sidebar-sticky-container');
    if (!sidebarStickyContainer) return;
  
    if (document.getElementById('vinted-sidebar-tabs')) {
      return; // D√©j√† cr√©√©
    }
  
    const tabsContainer = document.createElement('div');
    tabsContainer.id = 'vinted-sidebar-tabs';
    tabsContainer.className = 'vinted-sidebar-tabs';
    tabsContainer.innerHTML = `
      <button class="sidebar-tab active" data-tab="messages" title="Messages">
        <svg class="tab-icon tab-icon-messages" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
        </svg>
        <span class="tab-label">Messages</span>
        <span class="tab-count" id="messages-count">0</span>
      </button>
      <button class="sidebar-tab" data-tab="orders" title="Mes Commandes">
        <svg class="tab-icon tab-icon-orders" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z"></path>
        </svg>
        <span class="tab-label">Commandes</span>
        <span class="tab-count" id="orders-count">0</span>
      </button>
      <button class="sidebar-tab" data-tab="pickup" title="Points Relais">
        <svg class="tab-icon tab-icon-pickup" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
        </svg>
        <span class="tab-label">Relais</span>
        <span class="tab-count" id="pickup-count">0</span>
      </button>
      <button class="sidebar-tab" data-tab="filters" title="Filtres Sauvegard√©s">
        <svg class="tab-icon tab-icon-filters" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"></path>
        </svg>
        <span class="tab-label">Filtres</span>
        <span class="tab-count" id="filters-count">0</span>
      </button>
      <button class="sidebar-tab" data-tab="alerts" title="Alertes Prix">
        <svg class="tab-icon tab-icon-alerts" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"></path>
        </svg>
        <span class="tab-label">Alertes</span>
        <span class="tab-count" id="alerts-count">0</span>
      </button>
      <button class="sidebar-tab" data-tab="wardrobe" title="Mes Articles">
        <svg class="tab-icon tab-icon-wardrobe" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"></path>
        </svg>
        <span class="tab-label">Articles</span>
        <span class="tab-count" id="wardrobe-count">0</span>
      </button>
    `;
  
    // Ins√©rer en premier dans le sticky container
    sidebarStickyContainer.insertBefore(tabsContainer, sidebarStickyContainer.firstChild);
  
    // Event listeners pour les tabs
    tabsContainer.querySelectorAll('.sidebar-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const tabName = tab.dataset.tab;
        switchTab(tabName);
      });
    });
  
    // Observer le compteur de messages
    observeMessagesCount();
    
    // Mettre √† jour tous les compteurs
    updatePickupCount();
    updateFiltersCount();
    updateAlertsCount();
    refreshWardrobeCount(); // Mettre √† jour le compteur du wardrobe
    
    // Observer les changements dans les listes pour mettre √† jour les compteurs
    // Nettoyer l'observer existant s'il y en a un
    if (window.pickupFiltersAlertsObserver) {
      window.pickupFiltersAlertsObserver.disconnect();
    }
    
    // Utiliser un debounce pour √©viter les appels trop fr√©quents
    let debounceTimer = null;
    window.pickupFiltersAlertsObserver = new MutationObserver(() => {
      // Debounce: attendre 1000ms avant de mettre √† jour
      if (debounceTimer) {
        clearTimeout(debounceTimer);
      }
      debounceTimer = setTimeout(() => {
        updatePickupCount();
        updateFiltersCount();
        updateAlertsCount();
      }, 1000);
    });
    
    // Observer les listes de filtres, alertes et points relais
    setTimeout(() => {
      const filterList = document.getElementById('filter-list');
      const alertList = document.getElementById('alert-list');
      const pickupList = document.getElementById('pickup-points-list');
      
      if (filterList) {
        window.pickupFiltersAlertsObserver.observe(filterList, { childList: true, subtree: true });
      }
      if (alertList) {
        window.pickupFiltersAlertsObserver.observe(alertList, { childList: true, subtree: true });
      }
      if (pickupList) {
        window.pickupFiltersAlertsObserver.observe(pickupList, { childList: true, subtree: true });
      }
    }, 2000);
    
    // Initialiser l'affichage par d√©faut (messages) apr√®s un petit d√©lai
    setTimeout(() => {
      switchTab('messages');
    }, 100);
  }
  
  function switchTab(tabName) {
    activeTab = tabName;
  
    // Mettre √† jour les tabs
    document.querySelectorAll('.sidebar-tab').forEach(tab => {
      if (tab.dataset.tab === tabName) {
        tab.classList.add('active');
      } else {
        tab.classList.remove('active');
      }
    });
  
    // Afficher/masquer les sections
    const messagesContainer = document.getElementById('messages-sticky-container');
    const messagesListManager = document.getElementById('vinted-messages-list-manager');
    const ordersManager = document.getElementById('vinted-orders-manager');
    const pickupSystem = document.getElementById('pickup-points-system');
    const filterManager = document.getElementById('filter-manager');
    const alertSystem = document.getElementById('alert-system');
    const wardrobeManager = document.getElementById('vinted-wardrobe-manager');
  
    // Masquer toutes les sections
    if (messagesContainer) messagesContainer.style.display = 'none';
    if (messagesListManager) messagesListManager.style.display = 'none';
    if (ordersManager) ordersManager.style.display = 'none';
    if (pickupSystem) pickupSystem.style.display = 'none';
    if (filterManager) filterManager.style.display = 'none';
    if (alertSystem) alertSystem.style.display = 'none';
    if (wardrobeManager) wardrobeManager.style.display = 'none';
  
    // Afficher la section active
    switch(tabName) {
      case 'messages':
        if (messagesContainer) messagesContainer.style.display = 'block';
        if (messagesListManager) messagesListManager.style.display = 'block';
        // D√©marrer le rafra√Æchissement automatique des messages
        // (startMessagesAutoRefresh g√®re d√©j√† l'arr√™t d'un intervalle existant)
        if (typeof startMessagesAutoRefresh === 'function') {
          startMessagesAutoRefresh().catch(err => console.error('[Messages] Erreur:', err));
        }
        break;
      case 'orders':
        // Arr√™ter le rafra√Æchissement automatique si on change d'onglet
        stopMessagesAutoRefresh();
        if (ordersManager) ordersManager.style.display = 'block';
        break;
      case 'pickup':
        stopMessagesAutoRefresh();
        if (pickupSystem) pickupSystem.style.display = 'block';
        break;
      case 'filters':
        stopMessagesAutoRefresh();
        if (filterManager) filterManager.style.display = 'block';
        break;
      case 'alerts':
        stopMessagesAutoRefresh();
        if (alertSystem) alertSystem.style.display = 'block';
        break;
      case 'wardrobe':
        stopMessagesAutoRefresh();
        if (wardrobeManager) wardrobeManager.style.display = 'block';
        break;
      default:
        // Arr√™ter le rafra√Æchissement automatique si on change d'onglet
        stopMessagesAutoRefresh();
        break;
    }
  }
  
  let isUpdatingMessagesCount = false;
  
  async function updateMessagesCountInTab(conversations = null) {
    const messagesCountEl = document.getElementById('messages-count');
    if (!messagesCountEl) return;
  
    // √âviter les appels multiples simultan√©s
    if (isUpdatingMessagesCount && !conversations) {
      return;
    }
    
    isUpdatingMessagesCount = true;
  
    try {
      let unreadCount = 0;
      
      if (conversations) {
        // Utiliser les conversations d√©j√† charg√©es
        unreadCount = conversations.filter(conv => conv.unread === true).length;
      } else {
        // NE JAMAIS faire de fetchInbox ici si conversations est null
        // Utiliser uniquement le fallback du compteur existant
        const vintedMessagesCount = document.getElementById('vinted-messages-count');
        if (vintedMessagesCount) {
          const text = vintedMessagesCount.textContent.trim();
          const match = text.match(/\((\d+)\)/);
          if (match) {
            unreadCount = parseInt(match[1]);
          }
        }
      }
      
      if (unreadCount > 0) {
        messagesCountEl.textContent = unreadCount;
        messagesCountEl.style.display = 'inline-block';
      } else {
        messagesCountEl.textContent = '';
        messagesCountEl.style.display = 'none';
      }
    } catch (error) {
      console.error("[Messages Count] Erreur lors de la mise √† jour du compteur:", error);
    } finally {
      isUpdatingMessagesCount = false;
    }
  }
  
  function updateOrdersCount() {
    const ordersCountEl = document.getElementById('orders-count');
    if (!ordersCountEl) return;
  
    // Utiliser le cache si disponible, sinon charger
    if (cachedOrders !== null) {
      const inProgressCount = cachedOrders.filter(order => 
        order.transaction_user_status === 'needs_action'
      ).length;
      
      if (inProgressCount > 0) {
        ordersCountEl.textContent = inProgressCount;
        ordersCountEl.style.display = 'inline-block';
      } else {
        ordersCountEl.textContent = '';
        ordersCountEl.style.display = 'none';
      }
    } else {
      // Si pas encore charg√©, charger puis mettre √† jour
      loadAllOrders().then(() => {
        updateOrdersCount();
      }).catch(() => {
        ordersCountEl.textContent = '';
        ordersCountEl.style.display = 'none';
      });
    }
  }
  
  // Observer pour mettre √† jour le compteur de messages quand il change
  let messagesCountObserver = null;
  
  function observeMessagesCount() {
    // Nettoyer l'observer existant s'il y en a un
    if (messagesCountObserver) {
      messagesCountObserver.disconnect();
      messagesCountObserver = null;
    }
    
    const messagesCountEl = document.getElementById('vinted-messages-count');
    if (!messagesCountEl) {
      // R√©essayer apr√®s un d√©lai
      setTimeout(observeMessagesCount, 1000);
      return;
    }
    
    // Utiliser un debounce pour √©viter les appels trop fr√©quents
    let debounceTimer = null;
    let lastUpdateTime = 0;
    const MIN_UPDATE_INTERVAL = 5000; // Minimum 5 secondes entre les mises √† jour
    
    messagesCountObserver = new MutationObserver(() => {
      const now = Date.now();
      // Ne pas mettre √† jour si on a d√©j√† mis √† jour r√©cemment
      if (now - lastUpdateTime < MIN_UPDATE_INTERVAL) {
        return;
      }
      
      // Debounce: attendre 2000ms avant de mettre √† jour
      if (debounceTimer) {
        clearTimeout(debounceTimer);
      }
      debounceTimer = setTimeout(() => {
        // Ne JAMAIS appeler fetchInbox depuis le MutationObserver
        // Utiliser uniquement le fallback du compteur existant
        const messagesCountEl = document.getElementById('messages-count');
        if (messagesCountEl) {
          // Essayer de r√©cup√©rer le compteur depuis le DOM sans faire de requ√™te
          const vintedMessagesCount = document.getElementById('vinted-messages-count');
          if (vintedMessagesCount) {
            const text = vintedMessagesCount.textContent.trim();
            const match = text.match(/\((\d+)\)/);
            if (match) {
              const unreadCount = parseInt(match[1]);
              if (unreadCount > 0) {
                messagesCountEl.textContent = unreadCount;
                messagesCountEl.style.display = 'inline-block';
              } else {
                messagesCountEl.textContent = '';
                messagesCountEl.style.display = 'none';
              }
              lastUpdateTime = Date.now();
            }
          }
        }
      }, 2000);
    });
    
    messagesCountObserver.observe(messagesCountEl, {
      childList: true,
      characterData: true,
      subtree: true
    });
    
    // Ne pas mettre √† jour imm√©diatement depuis ici
    // La mise √† jour sera faite par loadMessages quand les donn√©es seront disponibles
  }
  
  function updatePickupCount() {
    const pickupCountEl = document.getElementById('pickup-count');
    if (!pickupCountEl) return;
  
    loadPickupPoints().then(points => {
      const count = points.length;
      if (count > 0) {
        pickupCountEl.textContent = count;
        pickupCountEl.style.display = 'inline-block';
      } else {
        pickupCountEl.textContent = '';
        pickupCountEl.style.display = 'none';
      }
    }).catch(() => {
      pickupCountEl.textContent = '';
      pickupCountEl.style.display = 'none';
    });
  }
  
  function updateFiltersCount() {
    const filtersCountEl = document.getElementById('filters-count');
    if (!filtersCountEl) return;
  
    // state.savedFilters devrait √™tre disponible
    if (typeof state !== 'undefined' && state.savedFilters) {
      const count = state.savedFilters.length;
      if (count > 0) {
        filtersCountEl.textContent = count;
        filtersCountEl.style.display = 'inline-block';
      } else {
        filtersCountEl.textContent = '';
        filtersCountEl.style.display = 'none';
      }
    } else {
      // Fallback: charger depuis le storage
      chrome.storage.local.get([CONFIG.STORAGE_KEY], (result) => {
        const filters = result[CONFIG.STORAGE_KEY] || [];
        const count = filters.length;
        if (count > 0) {
          filtersCountEl.textContent = count;
          filtersCountEl.style.display = 'inline-block';
        } else {
          filtersCountEl.textContent = '';
          filtersCountEl.style.display = 'none';
        }
      });
    }
  }
  
  function updateAlertsCount() {
    const alertsCountEl = document.getElementById('alerts-count');
    if (!alertsCountEl) return;
  
    // state.alerts devrait √™tre disponible
    if (typeof state !== 'undefined' && state.alerts) {
      const count = state.alerts.length;
      if (count > 0) {
        alertsCountEl.textContent = count;
        alertsCountEl.style.display = 'inline-block';
      } else {
        alertsCountEl.textContent = '';
        alertsCountEl.style.display = 'none';
      }
    } else {
      // Fallback: charger depuis le storage
      chrome.storage.local.get([CONFIG.ALERTS_STORAGE_KEY], (result) => {
        const alerts = result[CONFIG.ALERTS_STORAGE_KEY] || [];
        const count = alerts.length;
        if (count > 0) {
          alertsCountEl.textContent = count;
          alertsCountEl.style.display = 'inline-block';
        } else {
          alertsCountEl.textContent = '';
          alertsCountEl.style.display = 'none';
        }
      });
    }
  }

  // ==========================================
  // orders.js
  // ==========================================
  
  // ==================== ORDERS ====================
  function getAnonId() {
    const cookies = document.cookie.split(';');
    for (const cookie of cookies) {
      const [name, value] = cookie.trim().split('=');
      if (name === 'anon_id') {
        return decodeURIComponent(value);
      }
    }
    return null;
  }
  
  /**
   * R√©cup√®re les commandes depuis l'API Vinted
   * @param {string} type - 'purchased' pour les achats, 'sold' pour les ventes
   * @param {string} status - Statut de filtrage ('all', 'completed', 'waiting', 'needs_action', 'failed')
   * @param {number} page - Num√©ro de page
   * @param {number} perPage - Nombre d'√©l√©ments par page
   * @returns {Promise<Object|null>} - Donn√©es des commandes
   */
  async function fetchMyOrders(type = 'purchased', status = 'all', page = 1, perPage = 20) {
    try {
      const url = `https://www.vinted.fr/api/v2/my_orders?type=${type}&status=${status}&per_page=${perPage}&page=${page}`;
      const headers = {
        'accept': 'application/json, text/plain, */*',
        'accept-language': 'fr',
      };
      
      const anonId = getAnonId();
      if (anonId) {
        headers['x-anon-id'] = anonId;
      }
      
      const response = await fetch(url, {
        method: 'GET',
        credentials: 'include',
        headers: headers
      });
  
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
  
      const data = await response.json();
      return data;
    } catch (error) {
      console.error(`[Orders] Erreur lors de la r√©cup√©ration des commandes (${type}):`, error);
      return null;
    }
  }
  
  /**
   * Charge toutes les pages de commandes
   * @param {string} type - 'purchased' ou 'sold'
   * @param {string} status - Statut de filtrage
   * @returns {Promise<Array>} - Liste de toutes les commandes
   */
  async function loadAllOrders(type, status = 'all') {
    let allOrders = [];
    let currentPage = 1;
    let hasMore = true;
  
    while (hasMore) {
      const data = await fetchMyOrders(type, status, currentPage, 20);
      if (data && data.my_orders && data.my_orders.length > 0) {
        allOrders = [...allOrders, ...data.my_orders];
        const totalPages = data.pagination?.total_pages || 0;
        hasMore = currentPage < totalPages;
        currentPage++;
      } else {
        hasMore = false;
      }
    }
  
    return allOrders;
  }
  
  function formatOrderDate(dateString) {
    const date = new Date(dateString);
    return new Intl.DateTimeFormat('fr-FR', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    }).format(date);
  }
  
  function formatOrderPrice(price) {
    const amount = parseFloat(price.amount) || 0;
    const currency = price.currency_code || 'EUR';
    return new Intl.NumberFormat('fr-FR', {
      style: 'currency',
      currency: currency,
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(amount);
  }
  
  function getOrderStatusClass(status) {
    const statusLower = status.toLowerCase();
    if (statusLower.includes('finalis√©e') || statusLower.includes('valid√©') || statusLower.includes('livr√©e')) {
      return 'completed';
    } else if (statusLower.includes('remboursement') || statusLower.includes('annul')) {
      return 'failed';
    } else if (statusLower.includes('en cours') || statusLower.includes('attente') || statusLower.includes('bordereau')) {
      return 'waiting';
    } else if (statusLower.includes('action')) {
      return 'needs_action';
    } else {
      return 'in-progress';
    }
  }
  
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  function renderOrdersList(orders, type, statusFilter) {
    const listId = type === 'purchased' ? 'vinted-orders-purchased-list' : 'vinted-orders-sold-list';
    const ordersList = document.getElementById(listId);
    if (!ordersList) return;
  
    if (!orders || orders.length === 0) {
      ordersList.innerHTML = '<p class="orders-empty">Aucune commande</p>';
      return;
    }
  
    ordersList.innerHTML = orders.map(order => {
      const photoUrl = order.photo?.url || order.photo?.thumbnails?.[0]?.url || '';
      const price = formatOrderPrice(order.price);
      const date = formatOrderDate(order.date);
      const statusClass = getOrderStatusClass(order.status);
      const conversationUrl = `https://www.vinted.fr/inbox/${order.conversation_id}`;
  
      return `
        <div class="order-item" data-order-id="${order.transaction_id}">
          ${photoUrl ? `<img src="${photoUrl}" alt="${escapeHtml(order.title)}" class="order-photo" loading="lazy">` : '<div class="order-photo-placeholder">Pas de photo</div>'}
          <div class="order-info">
            <div class="order-title" title="${escapeHtml(order.title)}">${escapeHtml(order.title)}</div>
            <div class="order-price">${price}</div>
            <div class="order-date">${escapeHtml(date)}</div>
            <div class="order-status ${statusClass}">${escapeHtml(order.status)}</div>
          </div>
          <a href="${conversationUrl}" target="_blank" class="order-link" title="Voir la conversation">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
              <polyline points="15 3 21 3 21 9"></polyline>
              <line x1="10" y1="14" x2="21" y2="3"></line>
            </svg>
          </a>
        </div>
      `;
    }).join('');
  }
  
  // Cache pour les commandes
  let cachedPurchasedOrders = null;
  let cachedSoldOrders = null;
  let isLoadingPurchased = false;
  let isLoadingSold = false;
  
  // √âtat actuel
  let currentOrderType = 'purchased'; // 'purchased' ou 'sold'
  let currentPurchasedStatus = 'waiting'; // Par d√©faut "En attente" pour les achats
  let currentSoldStatus = 'needs_action'; // Par d√©faut "Action requise" pour les ventes
  
  /**
   * Charge toutes les commandes d'achat
   */
  async function loadAllPurchasedOrders() {
    if (isLoadingPurchased || cachedPurchasedOrders !== null) {
      return cachedPurchasedOrders;
    }
  
    isLoadingPurchased = true;
    const listContainer = document.getElementById('vinted-orders-purchased-list');
    if (listContainer) {
      listContainer.innerHTML = '<p class="orders-loading">Chargement des achats...</p>';
    }
  
    const orders = await loadAllOrders('purchased', 'all');
    cachedPurchasedOrders = orders;
    isLoadingPurchased = false;
  
    return orders;
  }
  
  /**
   * Charge toutes les commandes de vente
   */
  async function loadAllSoldOrders() {
    if (isLoadingSold || cachedSoldOrders !== null) {
      return cachedSoldOrders;
    }
  
    isLoadingSold = true;
    const listContainer = document.getElementById('vinted-orders-sold-list');
    if (listContainer) {
      listContainer.innerHTML = '<p class="orders-loading">Chargement des ventes...</p>';
    }
  
    const orders = await loadAllOrders('sold', 'all');
    cachedSoldOrders = orders;
    isLoadingSold = false;
  
    return orders;
  }
  
  /**
   * Filtre les commandes selon le statut
   */
  function filterOrders(type, status) {
    let orders = [];
    let filteredOrders = [];
  
    if (type === 'purchased') {
      if (cachedPurchasedOrders === null) {
        const listContainer = document.getElementById('vinted-orders-purchased-list');
        if (listContainer) {
          listContainer.innerHTML = '<p class="orders-loading">Chargement...</p>';
        }
        loadAllPurchasedOrders().then(() => filterOrders(type, status));
        return;
      }
      orders = cachedPurchasedOrders;
      currentPurchasedStatus = status;
    } else {
      if (cachedSoldOrders === null) {
        const listContainer = document.getElementById('vinted-orders-sold-list');
        if (listContainer) {
          listContainer.innerHTML = '<p class="orders-loading">Chargement...</p>';
        }
        loadAllSoldOrders().then(() => filterOrders(type, status));
      return;
      }
      orders = cachedSoldOrders;
      currentSoldStatus = status;
    }
  
    if (status === 'all') {
      filteredOrders = orders;
    } else {
      filteredOrders = orders.filter(order => {
        return order.transaction_user_status === status;
      });
    }
  
    renderOrdersList(filteredOrders, type, status);
    updateOrdersFilterButtons(type, status, orders);
  }
  
  /**
   * Change le type de commandes affich√©es (achats/ventes)
   */
  function switchOrderType(type) {
    currentOrderType = type;
    
    // Mettre √† jour les onglets
    const purchasedTab = document.getElementById('orders-tab-purchased');
    const soldTab = document.getElementById('orders-tab-sold');
    const purchasedSection = document.getElementById('vinted-orders-purchased-section');
    const soldSection = document.getElementById('vinted-orders-sold-section');
  
    if (purchasedTab && soldTab) {
      if (type === 'purchased') {
        purchasedTab.classList.add('active');
        soldTab.classList.remove('active');
        if (purchasedSection) purchasedSection.style.display = 'block';
        if (soldSection) soldSection.style.display = 'none';
      } else {
        soldTab.classList.add('active');
        purchasedTab.classList.remove('active');
        if (purchasedSection) purchasedSection.style.display = 'none';
        if (soldSection) soldSection.style.display = 'block';
      }
    }
  
    // Charger les commandes si n√©cessaire avec le filtre par d√©faut
    if (type === 'purchased') {
      const status = currentPurchasedStatus || 'waiting';
      filterOrders('purchased', status);
    } else {
      const status = currentSoldStatus || 'needs_action';
      filterOrders('sold', status);
    }
  }
  
  /**
   * Met √† jour les boutons de filtre avec les compteurs et le label de cat√©gorie
   */
  function updateOrdersFilterButtons(type, activeStatus, orders = null) {
    const containerId = type === 'purchased' ? 'vinted-orders-purchased-filters' : 'vinted-orders-sold-filters';
    const categoryLabelId = type === 'purchased' ? 'vinted-orders-purchased-category' : 'vinted-orders-sold-category';
    const buttons = document.querySelectorAll(`#${containerId} .order-filter-btn`);
    const categoryLabel = document.getElementById(categoryLabelId);
    
    // Calculer les compteurs
    let counts = { all: 0, waiting: 0, needs_action: 0, completed: 0, failed: 0 };
    if (orders) {
      counts.all = orders.length;
      counts.waiting = orders.filter(order => order.transaction_user_status === 'waiting').length;
      counts.needs_action = orders.filter(order => order.transaction_user_status === 'needs_action').length;
      counts.completed = orders.filter(order => order.transaction_user_status === 'completed').length;
      counts.failed = orders.filter(order => order.transaction_user_status === 'failed').length;
    }
    
    const categoryTexts = {
      'all': 'Toutes',
      'waiting': 'En attente',
      'needs_action': 'Action requise',
      'completed': 'Finalis√©es',
      'failed': 'Annul√©es'
    };
    
    // Mettre √† jour le label de cat√©gorie
    if (categoryLabel) {
      const categoryText = categoryTexts[activeStatus] || activeStatus;
      const count = counts[activeStatus] || 0;
      categoryLabel.textContent = `${categoryText} (${count})`;
    }
    
    // Mettre √† jour les boutons (actif/inactif)
    buttons.forEach(btn => {
      const status = btn.dataset.status;
      if (status === activeStatus) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });
  }
  
  /**
   * Met √† jour le compteur de commandes dans l'onglet
   */
  function updateOrdersCount() {
    const ordersTab = document.getElementById('sidebar-tab-orders');
    if (!ordersTab) return;
  
    let purchasedWaitingCount = 0;
    let soldNeedsActionCount = 0;
    
    if (cachedPurchasedOrders) {
      purchasedWaitingCount = cachedPurchasedOrders.filter(order => 
        order.transaction_user_status === 'waiting'
      ).length;
    }
    if (cachedSoldOrders) {
      soldNeedsActionCount = cachedSoldOrders.filter(order => 
        order.transaction_user_status === 'needs_action'
      ).length;
    }
  
    const countBadge = ordersTab.querySelector('.tab-count-badge');
    if (countBadge) {
      const totalCount = purchasedWaitingCount + soldNeedsActionCount;
      if (totalCount > 0) {
        // Afficher les deux compteurs s√©par√©s : "Achats en attente / Ventes action requise"
        let countText = '';
        if (purchasedWaitingCount > 0 && soldNeedsActionCount > 0) {
          countText = `${purchasedWaitingCount}/${soldNeedsActionCount}`;
        } else if (purchasedWaitingCount > 0) {
          countText = purchasedWaitingCount.toString();
        } else if (soldNeedsActionCount > 0) {
          countText = soldNeedsActionCount.toString();
        }
        
        if (countText) {
          countBadge.textContent = countText;
          countBadge.style.display = 'flex';
          countBadge.title = `Achats en attente: ${purchasedWaitingCount} | Ventes action requise: ${soldNeedsActionCount}`;
        } else {
          countBadge.style.display = 'none';
        }
      } else {
        countBadge.style.display = 'none';
      }
    }
  }
  
  let ordersManagerRetries = 0;
  const MAX_ORDERS_RETRIES = 10;
  
  function createOrdersManager() {
    const sidebar = document.getElementById('sidebar');
    if (!sidebar) {
      ordersManagerRetries++;
      if (ordersManagerRetries < MAX_ORDERS_RETRIES) {
        setTimeout(createOrdersManager, 500);
      }
      return;
    }
  
    if (document.getElementById('vinted-orders-manager')) {
      return; // D√©j√† cr√©√©
    }
  
    const ordersManager = document.createElement('div');
    ordersManager.id = 'vinted-orders-manager';
    ordersManager.className = 'vinted-orders-manager';
    ordersManager.style.display = 'none'; // Masqu√© par d√©faut
    ordersManager.innerHTML = `
      <div class="vinted-orders-manager-header">
        <h3 class="vinted-orders-manager-title">Mes Commandes</h3>
      </div>
      
      <!-- Onglets pour basculer entre Achats et Ventes -->
      <div class="vinted-orders-tabs">
        <button id="orders-tab-purchased" class="order-type-tab active" data-type="purchased">
          <svg class="tab-icon tab-icon-purchased" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"></path>
          </svg>
          <span class="tab-label">Achats</span>
        </button>
        <button id="orders-tab-sold" class="order-type-tab" data-type="sold">
          <svg class="tab-icon tab-icon-sold" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
          <span class="tab-label">Ventes</span>
        </button>
      </div>
  
      <!-- Section Achats -->
      <div id="vinted-orders-purchased-section" class="vinted-orders-section">
        <div id="vinted-orders-purchased-filters" class="vinted-orders-filters">
          <button class="order-filter-btn active" data-status="all" data-type="purchased" title="Toutes">
            <svg class="filter-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h16M4 14h16M4 18h16"></path>
            </svg>
          </button>
          <button class="order-filter-btn" data-status="waiting" data-type="purchased" title="En attente">
            <svg class="filter-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
          <button class="order-filter-btn" data-status="needs_action" data-type="purchased" title="Action requise">
            <svg class="filter-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
            </svg>
          </button>
          <button class="order-filter-btn" data-status="completed" data-type="purchased" title="Finalis√©es">
            <svg class="filter-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
            </svg>
          </button>
          <button class="order-filter-btn" data-status="failed" data-type="purchased" title="Annul√©es">
            <svg class="filter-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
          </button>
        </div>
        <div class="vinted-orders-category-label" id="vinted-orders-purchased-category">En attente</div>
        <div id="vinted-orders-purchased-list" class="vinted-orders-list">
          <p class="orders-loading">Chargement...</p>
        </div>
      </div>
  
      <!-- Section Ventes -->
      <div id="vinted-orders-sold-section" class="vinted-orders-section" style="display: none;">
        <div id="vinted-orders-sold-filters" class="vinted-orders-filters">
          <button class="order-filter-btn" data-status="all" data-type="sold" title="Toutes">
            <svg class="filter-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h16M4 14h16M4 18h16"></path>
            </svg>
          </button>
          <button class="order-filter-btn active" data-status="needs_action" data-type="sold" title="Action requise">
            <svg class="filter-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
            </svg>
          </button>
          <button class="order-filter-btn" data-status="completed" data-type="sold" title="Finalis√©es">
            <svg class="filter-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
            </svg>
          </button>
          <button class="order-filter-btn" data-status="failed" data-type="sold" title="Annul√©es">
            <svg class="filter-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
          </button>
        </div>
        <div class="vinted-orders-category-label" id="vinted-orders-sold-category">Action requise</div>
        <div id="vinted-orders-sold-list" class="vinted-orders-list">
        <p class="orders-loading">Chargement...</p>
        </div>
      </div>
    `;
  
    // Ins√©rer dans le sticky container
    const sidebarStickyContainer = document.getElementById('sidebar-sticky-container');
    const messagesStickyContainer = document.getElementById('messages-sticky-container');
    
    if (sidebarStickyContainer) {
      if (messagesStickyContainer) {
        if (messagesStickyContainer.nextSibling) {
          sidebarStickyContainer.insertBefore(ordersManager, messagesStickyContainer.nextSibling);
        } else {
          sidebarStickyContainer.appendChild(ordersManager);
        }
      } else {
        const filterManager = document.getElementById('filter-manager');
        if (filterManager && filterManager.parentNode) {
          filterManager.parentNode.insertBefore(ordersManager, filterManager);
        } else {
          sidebarStickyContainer.appendChild(ordersManager);
        }
      }
    } else {
      sidebar.insertBefore(ordersManager, sidebar.firstChild);
    }
  
    // Gestion des onglets Achats/Ventes
    const purchasedTab = document.getElementById('orders-tab-purchased');
    const soldTab = document.getElementById('orders-tab-sold');
    
    if (purchasedTab) {
      purchasedTab.addEventListener('click', () => switchOrderType('purchased'));
    }
    if (soldTab) {
      soldTab.addEventListener('click', () => switchOrderType('sold'));
    }
  
    // Gestion des filtres pour les achats
    const purchasedFilters = ordersManager.querySelectorAll('#vinted-orders-purchased-filters .order-filter-btn');
    purchasedFilters.forEach(btn => {
      btn.addEventListener('click', () => {
        const status = btn.dataset.status;
        filterOrders('purchased', status);
      });
    });
  
    // Gestion des filtres pour les ventes
    const soldFilters = ordersManager.querySelectorAll('#vinted-orders-sold-filters .order-filter-btn');
    soldFilters.forEach(btn => {
      btn.addEventListener('click', () => {
        const status = btn.dataset.status;
        filterOrders('sold', status);
      });
    });
  
    // Charger les commandes initiales avec les filtres par d√©faut
    loadAllPurchasedOrders().then(() => {
      filterOrders('purchased', 'waiting'); // Par d√©faut "En attente" pour les achats
      updateOrdersCount();
    });
    
    loadAllSoldOrders().then(() => {
      filterOrders('sold', 'needs_action'); // Par d√©faut "Action requise" pour les ventes
      updateOrdersCount();
    });
    
    console.log("[Orders Manager] Interface cr√©√©e avec succ√®s");
    ordersManagerRetries = 0;
  }
  
  

  // ==========================================
  // wardrobe.js
  // ==========================================
  
  // ==================== WARDROBE ITEMS ====================
  async function fetchWardrobeItems(userId, page = 1, perPage = 100, order = 'relevance') {
    try {
      const url = `https://www.vinted.fr/api/v2/wardrobe/${userId}/items?page=${page}&per_page=${perPage}&order=${order}`;
      const response = await fetch(url, {
        credentials: 'include',
        headers: {
          'accept': 'application/json, text/plain, */*',
          'accept-language': 'fr',
        }
      });
  
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
  
      const data = await response.json();
      return data;
    } catch (error) {
      console.error("[Wardrobe] Erreur lors de la r√©cup√©ration des items:", error);
      return null;
    }
  }
  
  function renderWardrobeItemsList(items, statusFilter) {
    const itemsList = document.getElementById('vinted-wardrobe-items-list');
    if (!itemsList) return;
  
    if (!items || items.length === 0) {
      itemsList.innerHTML = '<p class="wardrobe-items-empty">Aucun article</p>';
      return;
    }
  
    itemsList.innerHTML = items.map(item => {
      const photoUrl = item.photos?.[0]?.url || item.photos?.[0]?.thumbnails?.[0]?.url || '';
      const price = formatPrice(item);
      const status = item.status || 'N/A';
      const size = item.size || 'N/A';
      const brand = item.brand || '';
      const viewCount = item.view_count || 0;
      const favouriteCount = item.favourite_count || 0;
      const isClosed = item.is_closed || false;
      const isReserved = item.is_reserved || false;
      const itemUrl = item.url || `https://www.vinted.fr${item.path || ''}`;
  
      let statusBadge = '';
      if (isClosed) {
        statusBadge = '<span class="wardrobe-item-status-badge closed">Vendu</span>';
      } else if (isReserved) {
        statusBadge = '<span class="wardrobe-item-status-badge reserved">R√©serv√©</span>';
      } else {
        statusBadge = '<span class="wardrobe-item-status-badge active">Actif</span>';
      }
  
      return `
        <div class="wardrobe-item" data-item-id="${item.id}">
          ${photoUrl ? `<img src="${photoUrl}" alt="${escapeHtml(item.title)}" class="wardrobe-item-photo" loading="lazy">` : '<div class="wardrobe-item-photo-placeholder">Pas de photo</div>'}
          <div class="wardrobe-item-info">
            <div class="wardrobe-item-title">${escapeHtml(item.title)}</div>
            ${brand ? `<div class="wardrobe-item-brand">${escapeHtml(brand)}</div>` : ''}
            <div class="wardrobe-item-details">
              <span>${escapeHtml(size)}</span>
              <span>‚Ä¢</span>
              <span>${escapeHtml(status)}</span>
            </div>
            <div class="wardrobe-item-price">${price}</div>
            <div class="wardrobe-item-stats">
              <span>
                <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="display: inline-block; vertical-align: middle; margin-right: 4px;">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                </svg>
                ${viewCount}
              </span>
              <span>
                <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="display: inline-block; vertical-align: middle; margin-right: 4px;">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
                </svg>
                ${favouriteCount}
              </span>
            </div>
            ${statusBadge}
          </div>
          <a href="${itemUrl}" target="_blank" class="wardrobe-item-link" title="Voir l'article">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
              <polyline points="15 3 21 3 21 9"></polyline>
              <line x1="10" y1="14" x2="21" y2="3"></line>
            </svg>
          </a>
        </div>
      `;
    }).join('');
  }
  
  let currentWardrobeStatus = 'all';
  let cachedWardrobeItems = null;
  let isLoadingWardrobeItems = false;
  
  async function loadAllWardrobeItems() {
    // Si d√©j√† en cours de chargement ou d√©j√† charg√©, ne pas recharger
    if (isLoadingWardrobeItems || cachedWardrobeItems !== null) {
      return cachedWardrobeItems;
    }
  
    isLoadingWardrobeItems = true;
    const itemsContainer = document.getElementById('vinted-wardrobe-items-list');
    if (itemsContainer) {
      itemsContainer.innerHTML = '<p class="wardrobe-items-loading">Chargement...</p>';
    }
  
    const userId = await getUserId();
    if (!userId) {
      isLoadingWardrobeItems = false;
      if (itemsContainer) {
        itemsContainer.innerHTML = '<p class="wardrobe-items-empty">User ID non trouv√©</p>';
      }
      return null;
    }
  
    // Charger toutes les pages pour avoir tous les items
    let allItems = [];
    let currentPage = 1;
    let hasMore = true;
  
    while (hasMore) {
      const data = await fetchWardrobeItems(userId, currentPage, 20, 'relevance');
      if (data && data.items) {
        allItems = [...allItems, ...data.items];
        hasMore = currentPage < (data.pagination?.total_pages || 1);
        currentPage++;
      } else {
        hasMore = false;
      }
    }
  
    cachedWardrobeItems = allItems;
    isLoadingWardrobeItems = false;
  
    // Mettre √† jour le compteur dans l'onglet
    updateWardrobeCount(allItems.length);
  
    return allItems;
  }
  
  function filterWardrobeItems(status = 'all') {
    if (!cachedWardrobeItems || cachedWardrobeItems.length === 0) {
      const itemsContainer = document.getElementById('vinted-wardrobe-items-list');
      if (itemsContainer) {
        itemsContainer.innerHTML = '<p class="wardrobe-items-empty">Aucun article</p>';
      }
      return;
    }
  
    // Filtrer les items selon le statut (sans refaire de requ√™te)
    let filteredItems = cachedWardrobeItems;
    if (status !== 'all') {
      filteredItems = cachedWardrobeItems.filter(item => {
        if (status === 'active') {
          return !item.is_closed && !item.is_reserved && !item.is_hidden;
        } else if (status === 'closed') {
          return item.is_closed;
        } else if (status === 'reserved') {
          return item.is_reserved;
        }
        return true;
      });
    }
  
    renderWardrobeItemsList(filteredItems, status);
    currentWardrobeStatus = status;
  
    // Mettre √† jour les boutons de filtre avec les compteurs
    updateWardrobeFilterButtons(status, cachedWardrobeItems);
  }
  
  async function loadWardrobeItems(status = 'all') {
    // Charger toutes les donn√©es si pas encore charg√©es
    if (cachedWardrobeItems === null) {
      await loadAllWardrobeItems();
    }
  
    // Filtrer les donn√©es d√©j√† charg√©es
    filterWardrobeItems(status);
  }
  
  function updateWardrobeFilterButtons(activeStatus, items = null) {
    const buttons = document.querySelectorAll('.wardrobe-filter-btn');
    
    // Calculer les compteurs si les items sont fournis
    let counts = { all: 0, active: 0, closed: 0, reserved: 0 };
    if (items) {
      counts.all = items.length;
      counts.active = items.filter(item => !item.is_closed && !item.is_reserved && !item.is_hidden).length;
      counts.closed = items.filter(item => item.is_closed).length;
      counts.reserved = items.filter(item => item.is_reserved).length;
    }
    
    // Mapping des textes de base
    const baseTexts = {
      'all': 'Tous',
      'active': 'Actifs',
      'closed': 'Vendus',
      'reserved': 'R√©serv√©s'
    };
    
    buttons.forEach(btn => {
      const status = btn.dataset.status;
      if (status === activeStatus) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
      
      // Mettre √† jour le texte avec le compteur
      if (items) {
        const baseText = baseTexts[status] || status;
        btn.textContent = `${baseText} (${counts[status] || 0})`;
      }
    });
  }
  
  let wardrobeManagerRetries = 0;
  const MAX_WARDROBE_RETRIES = 10;
  
  function createWardrobeManager() {
    const sidebar = document.getElementById('sidebar');
    if (!sidebar) {
      wardrobeManagerRetries++;
      if (wardrobeManagerRetries < MAX_WARDROBE_RETRIES) {
        setTimeout(createWardrobeManager, 500);
      }
      return;
    }
  
    if (document.getElementById('vinted-wardrobe-manager')) {
      return; // D√©j√† cr√©√©
    }
  
    const wardrobeManager = document.createElement('div');
    wardrobeManager.id = 'vinted-wardrobe-manager';
    wardrobeManager.className = 'vinted-wardrobe-manager';
    wardrobeManager.style.display = 'none'; // Masqu√© par d√©faut
    wardrobeManager.innerHTML = `
      <div class="vinted-wardrobe-manager-header">
        <h3 class="vinted-wardrobe-manager-title">Mes Articles</h3>
      </div>
      <div class="vinted-wardrobe-filters">
        <button class="wardrobe-filter-btn active" data-status="all" title="Tous les articles">Tous</button>
        <button class="wardrobe-filter-btn" data-status="active" title="Articles actifs">Actifs</button>
        <button class="wardrobe-filter-btn" data-status="closed" title="Articles vendus">Vendus</button>
        <button class="wardrobe-filter-btn" data-status="reserved" title="Articles r√©serv√©s">R√©serv√©s</button>
      </div>
      <div id="vinted-wardrobe-items-list" class="vinted-wardrobe-items-list">
        <p class="wardrobe-items-loading">Chargement...</p>
      </div>
    `;
  
    // Ins√©rer dans le sticky container apr√®s le orders manager
    const sidebarStickyContainer = document.getElementById('sidebar-sticky-container');
    const ordersManager = document.getElementById('vinted-orders-manager');
    
    if (sidebarStickyContainer) {
      if (ordersManager) {
        // Ins√©rer apr√®s le orders-manager
        if (ordersManager.nextSibling) {
          sidebarStickyContainer.insertBefore(wardrobeManager, ordersManager.nextSibling);
        } else {
          sidebarStickyContainer.appendChild(wardrobeManager);
        }
      } else {
        // Si pas de orders manager, ins√©rer apr√®s messages ou avant filter-manager
        const messagesStickyContainer = document.getElementById('messages-sticky-container');
        if (messagesStickyContainer) {
          if (messagesStickyContainer.nextSibling) {
            sidebarStickyContainer.insertBefore(wardrobeManager, messagesStickyContainer.nextSibling);
          } else {
            sidebarStickyContainer.appendChild(wardrobeManager);
          }
        } else {
          const filterManager = document.getElementById('filter-manager');
          if (filterManager && filterManager.parentNode) {
            filterManager.parentNode.insertBefore(wardrobeManager, filterManager);
          } else {
            sidebarStickyContainer.appendChild(wardrobeManager);
          }
        }
      }
    } else {
      sidebar.insertBefore(wardrobeManager, sidebar.firstChild);
    }
  
    // Boutons de filtre
    const filterButtons = wardrobeManager.querySelectorAll('.wardrobe-filter-btn');
    filterButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const status = btn.dataset.status;
        // Filtrer uniquement c√¥t√© front-end, sans refaire de requ√™te
        filterWardrobeItems(status);
      });
    });
  
    // Charger les items initiaux (une seule fois)
    loadWardrobeItems('all');
    
    console.log("[Wardrobe Manager] Interface cr√©√©e avec succ√®s");
    wardrobeManagerRetries = 0;
  }
  
  function updateWardrobeCount(count) {
    const wardrobeCountEl = document.getElementById('wardrobe-count');
    if (wardrobeCountEl) {
      wardrobeCountEl.textContent = count > 0 ? count : '';
      wardrobeCountEl.style.display = count > 0 ? 'inline-block' : 'none';
    }
  }
  
  // Fonction pour mettre √† jour le compteur depuis le cache
  function refreshWardrobeCount() {
    if (cachedWardrobeItems !== null) {
      updateWardrobeCount(cachedWardrobeItems.length);
    } else {
      // Si pas encore charg√©, charger en arri√®re-plan pour avoir le compteur
      loadAllWardrobeItems().catch(err => {
        console.error("[Wardrobe] Erreur lors du chargement pour le compteur:", err);
      });
    }
  }

  // ==========================================
  // notifications.js
  // ==========================================
  
  // ==================== NOTIFICATIONS WIDGET ====================
  // Widget de notifications affich√© √† c√¥t√© du wallet avec rafra√Æchissement automatique
  
  let notificationsWidgetInterval = null;
  let cachedNotificationsData = null;
  let isNotificationsLoading = false;
  
  async function fetchNotificationsWidget(page = 1, perPage = 20) {
    try {
      const url = `https://www.vinted.fr/web/api/notifications/notifications?page=${page}&per_page=${perPage}`;
      const response = await fetch(url, {
        credentials: 'include',
        headers: {
          'accept': 'application/json, text/plain, */*',
          'accept-language': 'fr',
        }
      });
  
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
  
      const data = await response.json();
      return data;
    } catch (error) {
      console.error("[Notifications Widget] Erreur lors de la r√©cup√©ration des notifications:", error);
      return null;
    }
  }
  
  async function loadAllNotificationsWidget() {
    let allNotifications = [];
    let currentPage = 1;
    let hasMore = true;
  
    while (hasMore) {
      const data = await fetchNotificationsWidget(currentPage, 20);
      if (data && data.notifications) {
        allNotifications = [...allNotifications, ...data.notifications];
        const totalPages = data.pagination?.total_pages || 1;
        hasMore = currentPage < totalPages;
        currentPage++;
      } else {
        hasMore = false;
      }
    }
  
    return allNotifications;
  }
  
  function getNotificationTypeLabel(entryType) {
    const typeLabels = {
      20: 'Favori',
      40: 'Nouveaux articles',
      10: 'Message',
      30: 'Transaction',
    };
    return typeLabels[entryType] || `Type ${entryType}`;
  }
  
  function formatNotificationDate(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
  
    if (diffMins < 1) return '√Ä l\'instant';
    if (diffMins < 60) return `Il y a ${diffMins} min`;
    if (diffHours < 24) return `Il y a ${diffHours}h`;
    if (diffDays < 7) return `Il y a ${diffDays}j`;
    return date.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' });
  }
  
  function createNotificationItemWidget(notif) {
    const photoUrl = notif.photo?.url || notif.small_photo_url || notif.photo?.thumbnails?.[0]?.url || '';
    const body = notif.body || 'Notification';
    const link = notif.link ? `https://www.vinted.fr${notif.link}` : '#';
    const isRead = notif.is_read || false;
    const typeLabel = getNotificationTypeLabel(notif.entry_type);
    const date = formatNotificationDate(notif.updated_at);
  
    return `
      <div class="notification-widget-item ${isRead ? 'read' : 'unread'}" data-notification-id="${notif.id}">
        ${photoUrl ? `<img src="${photoUrl}" alt="Notification" class="notification-widget-photo" loading="lazy">` : '<div class="notification-widget-photo-placeholder">üì¢</div>'}
        <div class="notification-widget-info">
          <div class="notification-widget-body">${escapeHtml(body)}</div>
          <div class="notification-widget-meta">
            <span class="notification-widget-type">${escapeHtml(typeLabel)}</span>
            ${date ? `<span class="notification-widget-date">${escapeHtml(date)}</span>` : ''}
          </div>
        </div>
        <a href="${link}" target="_blank" class="notification-widget-link" title="Voir">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
            <polyline points="15 3 21 3 21 9"></polyline>
            <line x1="10" y1="14" x2="21" y2="3"></line>
          </svg>
        </a>
      </div>
    `;
  }
  
  function renderNotificationsWidget(notifications) {
    const panelContainer = document.getElementById('vinted-notifications-panel');
    if (!panelContainer) return;
  
    const listContainer = panelContainer.querySelector('.notifications-panel-list');
    if (!listContainer) return;
  
    if (!notifications || notifications.length === 0) {
      listContainer.innerHTML = '<p class="notifications-panel-empty">Aucune notification</p>';
      return;
    }
  
    // Afficher toutes les notifications (ou limiter √† 20)
    const displayNotifications = notifications.slice(0, 20);
  
    listContainer.innerHTML = displayNotifications.map(notif => createNotificationItemWidget(notif)).join('');
  
    // Mettre √† jour le compteur sur l'ic√¥ne
    const unreadCount = notifications.filter(n => !n.is_read).length;
    const iconButton = document.getElementById('vinted-notifications-icon');
    if (iconButton) {
      const countBadge = iconButton.querySelector('.notifications-icon-count');
      if (countBadge) {
        if (unreadCount > 0) {
          countBadge.textContent = unreadCount > 99 ? '99+' : unreadCount;
          countBadge.style.display = 'flex';
        } else {
          countBadge.style.display = 'none';
        }
      }
    }
  }
  
  async function refreshNotificationsWidget() {
    // √âviter les appels multiples simultan√©s
    if (isNotificationsLoading) {
      console.log("[Notifications] Chargement d√©j√† en cours, skip");
      return;
    }
    
    isNotificationsLoading = true;
    
    try {
      const notifications = await loadAllNotificationsWidget();
      if (notifications) {
        cachedNotificationsData = notifications;
        renderNotificationsWidget(notifications);
      }
    } catch (error) {
      console.error("[Notifications Widget] Erreur lors du rafra√Æchissement:", error);
    } finally {
      isNotificationsLoading = false;
    }
  }
  
  function createNotificationsWidget() {
    // V√©rifier si le widget existe d√©j√†
    if (document.getElementById('vinted-notifications-icon')) {
      return;
    }
  
    // Trouver le wallet pour placer l'ic√¥ne √† gauche
    const walletDisplay = document.getElementById('vinted-wallet-balance');
    if (!walletDisplay) {
      console.warn("[Notifications Widget] Wallet non trouv√©, r√©essai dans 1 seconde...");
      setTimeout(createNotificationsWidget, 1000);
      return;
    }
  
    // Trouver le conteneur parent du wallet (btnWrapper)
    const walletParent = walletDisplay.parentElement;
    if (!walletParent) {
      console.warn("[Notifications Widget] Parent du wallet non trouv√©");
      return;
    }
  
    // Cr√©er l'ic√¥ne de cloche (bouton)
    const iconButton = document.createElement('button');
    iconButton.id = 'vinted-notifications-icon';
    iconButton.className = 'vinted-notifications-icon';
    iconButton.innerHTML = '<svg class="notifications-icon-svg" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"></path></svg><span class="notifications-icon-count" style="display: none;">0</span>';
    iconButton.title = 'Notifications';
    iconButton.style.cssText = `
      position: relative;
      padding: 8px 12px;
      background: #6b7280;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 40px;
    `;
  
    // Cr√©er le panneau de notifications (masqu√© par d√©faut)
    const notificationsPanel = document.createElement('div');
    notificationsPanel.id = 'vinted-notifications-panel';
    notificationsPanel.className = 'vinted-notifications-panel';
    notificationsPanel.style.display = 'none';
    notificationsPanel.innerHTML = `
      <div class="notifications-panel-header">
        <span class="notifications-panel-title">Notifications</span>
        <button class="notifications-panel-close" title="Fermer">√ó</button>
      </div>
      <div class="notifications-panel-list">
        <p class="notifications-panel-loading">Chargement...</p>
      </div>
    `;
  
    // Trouver le bouton toggle (d√©marrer) pour placer l'ic√¥ne apr√®s
    const toggleBtn = document.getElementById('toggle-monitor');
    if (toggleBtn && toggleBtn.parentElement === walletParent) {
      // Ins√©rer l'ic√¥ne APR√àS le bouton toggle (tout √† droite)
      walletParent.insertBefore(iconButton, toggleBtn.nextSibling);
    } else {
      // Fallback : ins√©rer √† la fin du btnWrapper
      walletParent.appendChild(iconButton);
    }
  
    // Ins√©rer le panneau apr√®s le btnWrapper (en position absolue)
    const btnWrapperParent = walletParent.parentElement;
    if (btnWrapperParent) {
      btnWrapperParent.appendChild(notificationsPanel);
    } else {
      document.body.appendChild(notificationsPanel);
    }
  
    let isPanelOpen = false;
  
    // Toggle du panneau au clic sur l'ic√¥ne
    iconButton.addEventListener('click', (e) => {
      e.stopPropagation();
      isPanelOpen = !isPanelOpen;
      if (isPanelOpen) {
        notificationsPanel.style.display = 'block';
        // Charger les notifications si pas encore charg√©es
        if (!cachedNotificationsData) {
          refreshNotificationsWidget();
        } else {
          renderNotificationsWidget(cachedNotificationsData);
        }
      } else {
        notificationsPanel.style.display = 'none';
      }
    });
  
    // Fermer le panneau au clic sur le bouton fermer
    const closeBtn = notificationsPanel.querySelector('.notifications-panel-close');
    if (closeBtn) {
      closeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        isPanelOpen = false;
        notificationsPanel.style.display = 'none';
      });
    }
  
    // Fermer le panneau si on clique en dehors
    document.addEventListener('click', (e) => {
      if (isPanelOpen && 
          !notificationsPanel.contains(e.target) && 
          !iconButton.contains(e.target)) {
        isPanelOpen = false;
        notificationsPanel.style.display = 'none';
      }
    });
  
    // Charger les notifications initiales en arri√®re-plan
    refreshNotificationsWidget();
  
    // D√©marrer le rafra√Æchissement automatique selon l'intervalle configur√©
    if (notificationsWidgetInterval) {
      clearInterval(notificationsWidgetInterval);
      notificationsWidgetInterval = null;
    }
    
    // Obtenir l'intervalle depuis les settings ou la config
    const getNotificationsInterval = async () => {
      if (typeof getInterval === 'function') {
        return await getInterval('notifications');
      }
      return CONFIG.NOTIFICATIONS_REFRESH_INTERVAL || 10000;
    };
    
    getNotificationsInterval().then(interval => {
      // S'assurer qu'on ne cr√©e pas plusieurs intervalles
      if (notificationsWidgetInterval) {
        clearInterval(notificationsWidgetInterval);
      }
      
      notificationsWidgetInterval = setInterval(() => {
        // √âviter les appels multiples si une requ√™te est d√©j√† en cours
        if (isNotificationsLoading) {
          console.log("[Notifications] Requ√™te en cours, skip du rafra√Æchissement");
          return;
        }
        refreshNotificationsWidget();
      }, interval);
      
      console.log(`[Notifications] ‚úÖ Rafra√Æchissement automatique activ√© (toutes les ${interval / 1000} secondes)`);
    });
  
    console.log("[Notifications Widget] Widget cr√©√© avec succ√®s");
  }
  
  function stopNotificationsWidgetRefresh() {
    if (notificationsWidgetInterval) {
      clearInterval(notificationsWidgetInterval);
      notificationsWidgetInterval = null;
    }
  }

  // ==========================================
  // messages.js
  // ==========================================
  
  // ==================== MESSAGES ====================
  // Variable globale pour stocker le token CSRF intercept√©
  let cachedCsrfToken = null;
  let csrfTokenCacheTime = 0;
  const CSRF_TOKEN_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
  
  /**
   * Intercepte les requ√™tes fetch pour r√©cup√©rer le token CSRF
   */
  function interceptFetchForCsrfToken() {
    if (window._vintedCsrfIntercepted) return;
    window._vintedCsrfIntercepted = true;
    
    const originalFetch = window.fetch;
    window.fetch = function(...args) {
      const [url, options = {}] = args;
      
      // Si c'est une requ√™te vers l'API Vinted avec un header x-csrf-token
      if (typeof url === 'string' && url.includes('vinted.fr/api')) {
        let csrfToken = null;
        if (options.headers) {
          if (options.headers instanceof Headers) {
            csrfToken = options.headers.get('x-csrf-token') || options.headers.get('X-CSRF-Token');
          } else {
            csrfToken = options.headers['x-csrf-token'] || 
                       options.headers['X-CSRF-Token'] ||
                       options.headers['X-Csrf-Token'];
          }
        }
        
        if (csrfToken) {
          cachedCsrfToken = csrfToken;
          csrfTokenCacheTime = Date.now();
        }
      }
      
      return originalFetch.apply(this, args);
    };
    
    // Intercepter aussi XMLHttpRequest
    if (window.XMLHttpRequest) {
      const originalSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
      XMLHttpRequest.prototype.setRequestHeader = function(header, value) {
        if (header.toLowerCase() === 'x-csrf-token' && value) {
          cachedCsrfToken = value;
          csrfTokenCacheTime = Date.now();
        }
        return originalSetRequestHeader.apply(this, arguments);
      };
    }
  }
  
  /**
   * R√©cup√®re le token CSRF depuis les cookies ou les meta tags
   * @returns {Promise<string|null>} - Token CSRF
   */
  async function getCsrfToken() {
    // M√©thode 1: Depuis le cache (intercept√© depuis une requ√™te) - avec expiration
    const now = Date.now();
    if (cachedCsrfToken && (now - csrfTokenCacheTime) < CSRF_TOKEN_CACHE_DURATION) {
      return cachedCsrfToken;
    }
    // Cache expir√©, le vider
    if (cachedCsrfToken && (now - csrfTokenCacheTime) >= CSRF_TOKEN_CACHE_DURATION) {
      cachedCsrfToken = null;
      csrfTokenCacheTime = 0;
    }
    
    // M√©thode 2: Extraire le token CSRF depuis les scripts inline de la page
    // Le token est dans un script avec pattern: "CSRF_TOKEN":"[token]" dans __next_f.push
    try {
      const scripts = document.querySelectorAll('script:not([src])');
      for (const script of scripts) {
        const scriptContent = script.textContent || script.innerHTML;
        if (scriptContent && scriptContent.includes('CSRF_TOKEN')) {
          // Pattern principal: "CSRF_TOKEN":"[token]" ou CSRF_TOKEN":"[token]" (avec/sans guillemets)
          const patterns = [
            /"CSRF_TOKEN"\s*:\s*"([a-f0-9-]{36,})"/i,
            /CSRF_TOKEN"\s*:\s*"([a-f0-9-]{36,})"/i,
            /CSRF_TOKEN[\\"]*:\s*[\\"]*([a-f0-9-]{36,})/i
          ];
          
          for (const pattern of patterns) {
            const match = scriptContent.match(pattern);
            if (match && match[1] && match[1].length > 20) {
              cachedCsrfToken = match[1];
              csrfTokenCacheTime = Date.now();
              return match[1];
            }
          }
        }
      }
      
      // Fallback: Chercher dans le HTML complet
      const htmlContent = document.documentElement.outerHTML || document.body.innerHTML;
      if (htmlContent.includes('CSRF_TOKEN')) {
        const htmlMatch = htmlContent.match(/"CSRF_TOKEN"\s*:\s*"([a-f0-9-]{36,})"/i);
        if (htmlMatch && htmlMatch[1] && htmlMatch[1].length > 20) {
          cachedCsrfToken = htmlMatch[1];
          csrfTokenCacheTime = Date.now();
          return htmlMatch[1];
        }
      }
    } catch (e) {
      // Ignorer les erreurs
    }
    
    // M√©thode 3: Depuis window.__NEXT_DATA__?.env (fallback)
    if (window.__NEXT_DATA__?.env?.CSRF_TOKEN) {
      const token = window.__NEXT_DATA__.env.CSRF_TOKEN;
      if (token && typeof token === 'string' && token.length > 20) {
        cachedCsrfToken = token;
        csrfTokenCacheTime = Date.now();
        return token;
      }
    }
    
    return null;
  }
  
  /**
   * Essaie de r√©cup√©rer le token CSRF depuis la page en faisant une requ√™te
   */
  async function tryGetCsrfTokenFromPage() {
    try {
      // Essayer de r√©cup√©rer depuis la page inbox
      const inboxResponse = await fetch('https://www.vinted.fr/inbox', {
        credentials: "include",
        headers: {
          "accept": "text/html,application/xhtml+xml",
        },
      });
      
      if (inboxResponse.ok) {
        const html = await inboxResponse.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Chercher dans les meta tags (tous les variants)
        const metaSelectors = [
          'meta[name="csrf-token"]',
          'meta[name="csrf_token"]',
          'meta[name="CSRF-Token"]',
          'meta[property="csrf-token"]'
        ];
        
        for (const selector of metaSelectors) {
          const metaTag = doc.querySelector(selector);
          if (metaTag) {
            const token = metaTag.getAttribute('content');
            if (token && token.length > 20) {
              return token;
            }
          }
        }
        
        // Chercher dans les attributs data
        const dataTag = doc.querySelector('[data-csrf-token], body[data-csrf-token], html[data-csrf-token]');
        if (dataTag) {
          const token = dataTag.getAttribute('data-csrf-token') || 
                       dataTag.getAttribute('data-csrf_token') ||
                       dataTag.getAttribute('data-csrf');
          if (token && token.length > 20) {
            return token;
          }
        }
        
        // Chercher dans le HTML avec des patterns am√©lior√©s
        const patterns = [
          /csrf[_-]?token["\s:=]+["']?([a-f0-9-]{36,})["']?/i,
          /["']x-csrf-token["']\s*:\s*["']([a-f0-9-]{36,})["']/i,
          /x-csrf-token["\s:=]+["']?([a-f0-9-]{36,})["']?/i,
          /csrfToken["\s:=]+["']?([a-f0-9-]{36,})["']?/i,
          /csrf_token["\s:=]+["']?([a-f0-9-]{36,})["']?/i
        ];
        
        for (const pattern of patterns) {
          const match = html.match(pattern);
          if (match && match[1] && match[1].length > 20) {
            return match[1];
          }
        }
      }
    } catch (error) {
      console.error("[Vinted Messages] Erreur lors de la r√©cup√©ration du token:", error);
    }
    
    return null;
  }
  
  /**
   * R√©cup√®re l'anon_id depuis les cookies
   * @returns {string|null} - Anon ID
   */
  function getAnonId() {
    const cookies = document.cookie.split(';');
    for (const cookie of cookies) {
      const [name, value] = cookie.trim().split('=');
      if (name === 'anon_id') {
        return decodeURIComponent(value);
      }
    }
    return null;
  }
  
  // Initialiser l'interception au chargement
  if (typeof window !== 'undefined') {
    interceptFetchForCsrfToken();
  }
  
  // Fonctions pour g√©rer les conversations
  async function fetchConversation(conversationId) {
    try {
      const url = `https://www.vinted.fr/api/v2/conversations/${conversationId}`;
      const response = await fetch(url, {
        credentials: "include",
        headers: {
          "accept": "application/json, text/plain, */*",
          "accept-language": "fr",
          "sec-fetch-dest": "empty",
          "sec-fetch-mode": "cors",
          "sec-fetch-site": "same-origin",
        },
      });
  
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
  
      const data = await response.json();
      return data.conversation;
    } catch (error) {
      console.error("[Messages] Erreur lors de la r√©cup√©ration de la conversation:", error);
      throw error;
    }
  }
  
  async function sendMessage(conversationId, messageBody) {
    console.log("[Vinted Messages] sendMessage appel√© avec conversationId:", conversationId, "messageBody:", messageBody?.substring(0, 50));
    
    const url = `https://www.vinted.fr/api/v2/conversations/${conversationId}/replies`;
    console.log("[Vinted Messages] URL de la requ√™te:", url);
    
    // R√©cup√©rer le token CSRF et l'anon_id
    console.log("[Vinted Messages] R√©cup√©ration du token CSRF...");
    let csrfToken = await getCsrfToken();
    console.log("[Vinted Messages] Token CSRF r√©cup√©r√©:", csrfToken ? csrfToken.substring(0, 8) + '...' : 'null');
    
    const anonId = getAnonId();
    console.log("[Vinted Messages] Anon ID:", anonId || 'non trouv√©');
    
    // Si pas de token, essayer de le r√©cup√©rer depuis la page inbox
    if (!csrfToken) {
      console.warn("[Vinted Messages] Token CSRF non trouv√©, tentative de r√©cup√©ration depuis la page...");
      csrfToken = await tryGetCsrfTokenFromPage();
      if (csrfToken) {
        cachedCsrfToken = csrfToken;
        csrfTokenCacheTime = Date.now();
        console.log("[Vinted Messages] Token CSRF r√©cup√©r√© depuis la page");
      }
    }
    
    if (!csrfToken) {
      const error = "Impossible de r√©cup√©rer le token CSRF. Veuillez recharger la page et r√©essayer.";
      console.error("[Vinted Messages]", error);
      throw new Error(error);
    }
    
    console.log("[Vinted Messages] Envoi du message avec token CSRF:", csrfToken.substring(0, 8) + '...');
    
    const payload = {
      reply: {
        body: messageBody,
        photo_temp_uuids: null,
        is_personal_data_sharing_check_skipped: false
      }
    };
    
    try {
      const headers = {
        "content-type": "application/json",
        "x-csrf-token": csrfToken,
        "accept": "application/json, text/plain, */*",
      };
      
      // Ajouter l'anon_id si disponible (optionnel mais peut aider)
      if (anonId) {
        headers["x-anon-id"] = anonId;
      }
      
      // S'assurer que les cookies (y compris DataDome) sont inclus
      const fetchOptions = {
        method: "POST",
        credentials: "include", // Inclut automatiquement les cookies (y compris DataDome)
        headers: headers,
        body: JSON.stringify(payload),
        mode: "cors",
        cache: "no-cache",
      };
      
      const response = await fetch(url, fetchOptions);
  
      if (!response.ok) {
        let errorData;
        try {
          errorData = await response.json();
        } catch {
          const errorText = await response.text();
          errorData = { message: errorText };
        }
        console.error("[Vinted Messages] Erreur API:", errorData);
        
        // Si c'est une erreur d'acc√®s refus√©, essayer de r√©cup√©rer le token depuis la page
        if (errorData.code === 106 || response.status === 403) {
          console.warn("[Vinted Messages] Acc√®s refus√©, tentative de r√©cup√©ration du token CSRF depuis la page");
          
          // Recharger la page pour r√©cup√©rer le token (ou essayer une autre m√©thode)
          const newCsrfToken = await tryGetCsrfTokenFromPage();
          if (newCsrfToken && newCsrfToken !== csrfToken) {
            headers["x-csrf-token"] = newCsrfToken;
            cachedCsrfToken = newCsrfToken;
            csrfTokenCacheTime = Date.now();
            // R√©essayer avec le nouveau token
            const retryResponse = await fetch(url, {
              method: "POST",
              credentials: "include",
              headers: headers,
              body: JSON.stringify(payload),
            });
            
            if (!retryResponse.ok) {
              let retryError;
              try {
                retryError = await retryResponse.json();
              } catch {
                const retryErrorText = await retryResponse.text();
                retryError = { message: retryErrorText };
              }
              throw new Error(`HTTP ${retryResponse.status}: ${JSON.stringify(retryError)}`);
            }
            
            return await retryResponse.json();
          }
        }
        
        throw new Error(`HTTP ${response.status}: ${JSON.stringify(errorData)}`);
      }
  
      const data = await response.json();
      return data;
    } catch (error) {
      console.error("[Vinted Messages] Erreur lors de l'envoi du message:", error);
      throw error;
    }
  }
  
  async function sendOfferRequest(transactionId, price, currency = "EUR") {
    const url = `https://www.vinted.fr/api/v2/transactions/${transactionId}/offer_requests`;
    
    let csrfToken = await getCsrfToken();
    const anonId = getAnonId();
    
    if (!csrfToken) {
      csrfToken = await tryGetCsrfTokenFromPage();
      if (csrfToken) {
        cachedCsrfToken = csrfToken;
        csrfTokenCacheTime = Date.now();
      }
    }
    
    if (!csrfToken) {
      throw new Error("Impossible de r√©cup√©rer le token CSRF. Veuillez recharger la page et r√©essayer.");
    }
    
    const headers = {
      "content-type": "application/json",
      "x-csrf-token": csrfToken,
      "accept": "application/json, text/plain, */*",
    };
    
    // Ajouter l'anon_id si disponible
    if (anonId) {
      headers["x-anon-id"] = anonId;
    }
    
    try {
      const response = await fetch(url, {
        method: "POST",
        credentials: "include",
        headers: headers,
        body: JSON.stringify({
          offer_request: {
            price: price.toString(),
            currency: currency
          }
        })
      });
  
      if (!response.ok) {
        let errorData;
        try {
          errorData = await response.json();
        } catch {
          const errorText = await response.text();
          errorData = { message: errorText };
        }
        
        // Si c'est une erreur d'acc√®s refus√©, essayer de r√©cup√©rer le token depuis la page
        if (errorData.code === 106 || response.status === 403) {
          cachedCsrfToken = null;
          csrfTokenCacheTime = 0;
          const newToken = await tryGetCsrfTokenFromPage();
          if (newToken) {
            cachedCsrfToken = newToken;
            csrfTokenCacheTime = Date.now();
            headers["x-csrf-token"] = newToken;
            // R√©essayer avec le nouveau token
            const retryResponse = await fetch(url, {
              method: "POST",
              credentials: "include",
              headers: headers,
              body: JSON.stringify({
                offer_request: {
                  price: price.toString(),
                  currency: currency
                }
              })
            });
            
            if (!retryResponse.ok) {
              throw new Error(`HTTP ${retryResponse.status}`);
            }
            
            return await retryResponse.json();
          }
        }
        
        throw new Error(`HTTP ${response.status}: ${JSON.stringify(errorData)}`);
      }
  
      return await response.json();
    } catch (error) {
      console.error("[Vinted Messages] Erreur lors de l'envoi de l'offre:", error);
      throw error;
    }
  }
  
  function formatMessage(message, currentUserId, conversationUrl, transaction = null) {
    // D√©terminer si le message est de l'utilisateur actuel
    // Pour les messages d'offre, utiliser user_id de l'entit√©
    const messageUserId = message.entity?.user_id;
    const isCurrentUser = messageUserId === currentUserId;
    const messageClass = isCurrentUser ? 'vinted-msg-current-user' : 'vinted-msg-other-user';
    
    // Formater la date - created_at_ts peut √™tre une cha√Æne ISO 8601 ou un timestamp
    let timeAgo = message.created_time_ago || '';
    if (!timeAgo && message.created_at_ts) {
      try {
        // Si c'est une cha√Æne ISO 8601, la parser directement
        const date = new Date(message.created_at_ts);
        if (!isNaN(date.getTime())) {
          // Formater la date de mani√®re relative
          const now = new Date();
          const diffMs = now - date;
          const diffMins = Math.floor(diffMs / 60000);
          const diffHours = Math.floor(diffMs / 3600000);
          const diffDays = Math.floor(diffMs / 86400000);
          
          if (diffMins < 1) {
            timeAgo = '√Ä l\'instant';
          } else if (diffMins < 60) {
            timeAgo = `Il y a ${diffMins} min`;
          } else if (diffHours < 24) {
            timeAgo = `Il y a ${diffHours}h`;
          } else if (diffDays < 7) {
            timeAgo = `Il y a ${diffDays}j`;
          } else {
            timeAgo = new Intl.DateTimeFormat('fr-FR', {
              day: '2-digit',
              month: '2-digit',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit'
            }).format(date);
          }
        }
      } catch (e) {
        console.error("[Vinted Messages] Erreur lors du formatage de la date:", e, message.created_at_ts);
        timeAgo = '';
      }
    }
    
    let content = '';
    
    if (message.entity_type === 'message') {
      content = `<div class="vinted-msg-body">${escapeHtml(message.entity.body)}</div>`;
    } else if (message.entity_type === 'status_message') {
      content = `
        <div class="vinted-msg-status">
          <div class="vinted-msg-status-title">${escapeHtml(message.entity.title)}</div>
          ${message.entity.subtitle ? `<div class="vinted-msg-status-subtitle">${escapeHtml(message.entity.subtitle)}</div>` : ''}
        </div>
      `;
    } else if (message.entity_type === 'action_message') {
      content = `
        <div class="vinted-msg-action">
          <div class="vinted-msg-action-title">${escapeHtml(message.entity.title)}</div>
          ${message.entity.subtitle ? `<div class="vinted-msg-action-subtitle">${escapeHtml(message.entity.subtitle)}</div>` : ''}
          ${message.entity.actions && message.entity.actions.length > 0 ? `
            <div class="vinted-msg-actions">
              ${message.entity.actions.map(action => {
                let actionUrl = conversationUrl;
                if (action.action === 'track_shipment' && transaction?.id) {
                  actionUrl = `https://www.vinted.fr/transactions/${transaction.id}`;
                }
                return `<a href="${actionUrl}" target="_blank" class="vinted-msg-action-btn">${escapeHtml(action.title)}</a>`;
              }).join('')}
            </div>
          ` : ''}
        </div>
      `;
    } else if (message.entity_type === 'offer_request_message') {
      // Message d'offre demand√©e (par l'acheteur)
      const statusText = message.entity.status_title ? ` (${escapeHtml(message.entity.status_title)})` : '';
      content = `
        <div class="vinted-msg-offer">
          <div class="vinted-msg-offer-title">${escapeHtml(message.entity.title || 'Offre demand√©e')}${statusText}</div>
          <div class="vinted-msg-offer-price">${escapeHtml(message.entity.price_label || message.entity.body || '')}</div>
          ${message.entity.original_price_label ? `<div class="vinted-msg-offer-original">Prix original: ${escapeHtml(message.entity.original_price_label)}</div>` : ''}
        </div>
      `;
    } else if (message.entity_type === 'offer_message') {
      // Message d'offre accept√©e (par le vendeur)
      content = `
        <div class="vinted-msg-offer accepted">
          <div class="vinted-msg-offer-title">Offre accept√©e</div>
          <div class="vinted-msg-offer-price">${escapeHtml(message.entity.price_label || '')}</div>
          ${message.entity.original_price_label ? `<div class="vinted-msg-offer-original">Prix original: ${escapeHtml(message.entity.original_price_label)}</div>` : ''}
        </div>
      `;
    }
    
    // Ne pas afficher de message vide
    if (!content) {
      return '';
    }
    
    return `
      <div class="vinted-msg-item ${messageClass}">
        ${content}
        <div class="vinted-msg-time">${escapeHtml(timeAgo)}</div>
      </div>
    `;
  }
  
  async function fetchInbox(page = 1, perPage = 20) {
    // Limiter le nombre de conversations charg√©es pour r√©duire la m√©moire
    const MAX_CONVERSATIONS = 30;
    if (perPage > MAX_CONVERSATIONS) perPage = MAX_CONVERSATIONS;
    try {
      const url = `https://www.vinted.fr/api/v2/inbox?page=${page}&per_page=${perPage}`;
      const response = await fetch(url, {
        credentials: "include",
        headers: {
          "accept": "application/json, text/plain, */*",
          "accept-language": "fr",
          "sec-fetch-dest": "empty",
          "sec-fetch-mode": "cors",
          "sec-fetch-site": "same-origin",
        },
      });
  
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
  
      const data = await response.json();
      return data;
    } catch (error) {
      console.error("[Messages] Erreur lors de la r√©cup√©ration des messages:", error);
      return null;
    }
  }
  
  function formatMessageDate(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
  
    if (diffMins < 1) return '√Ä l\'instant';
    if (diffMins < 60) return `Il y a ${diffMins} min`;
    if (diffHours < 24) return `Il y a ${diffHours}h`;
    if (diffDays < 7) return `Il y a ${diffDays}j`;
    
    return new Intl.DateTimeFormat('fr-FR', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    }).format(date);
  }
  
  function renderMessagesList(conversations, readFilter) {
    const messagesList = document.getElementById('vinted-messages-list');
    if (!messagesList) return;
  
    if (!conversations || conversations.length === 0) {
      messagesList.innerHTML = '<p class="messages-empty">Aucun message</p>';
      return;
    }
  
    const messagesHtml = conversations.map(conv => {
      const photoUrl = conv.opposite_user?.photo?.thumbnails?.find(t => t.type === "thumb100")?.url || 
                       conv.opposite_user?.photo?.url || 
                       'https://via.placeholder.com/50';
      const username = conv.opposite_user?.login || 'Utilisateur';
      const description = conv.description || '';
      const date = formatMessageDate(conv.updated_at);
      const isUnread = conv.unread === true;
      const unreadClass = isUnread ? 'unread' : '';
      const conversationUrl = `https://www.vinted.fr/inbox/${conv.id}`;
      const itemPhoto = conv.item_photos?.[0]?.thumbnails?.find(t => t.type === "thumb70x100")?.url || 
                        conv.item_photos?.[0]?.url || '';
  
      return `
        <div class="message-item ${unreadClass}" data-conversation-id="${conv.id}" style="cursor: pointer;">
          ${itemPhoto ? `<img src="${itemPhoto}" alt="Article" class="message-item-photo">` : `<img src="${photoUrl}" alt="${escapeHtml(username)}" class="message-avatar">`}
          <div class="message-info">
            <div class="message-header">
              <div class="message-username">${escapeHtml(username)}</div>
              ${isUnread ? '<span class="message-unread-badge">‚óè</span>' : ''}
            </div>
            <div class="message-description">${escapeHtml(description)}</div>
            <div class="message-date">${date}</div>
          </div>
          <a href="${conversationUrl}" target="_blank" class="message-link" title="Ouvrir la conversation" onclick="event.stopPropagation();">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
              <polyline points="15 3 21 3 21 9"></polyline>
              <line x1="10" y1="14" x2="21" y2="3"></line>
            </svg>
          </a>
        </div>
      `;
    }).join('');
    
    messagesList.innerHTML = messagesHtml;
    
    // Utiliser la d√©l√©gation d'√©v√©nements pour √©viter d'ajouter des listeners √† chaque rendu
    // Le listener est d√©j√† attach√© dans createMessagesListManager
  }
  
  let currentMessagesFilter = 'all';
  let currentMessagesPage = 1;
  let messagesRefreshInterval = null;
  
  async function loadMessages(readFilter = 'all', page = 1) {
    // √âviter les appels multiples simultan√©s
    if (isMessagesLoading) {
      console.log("[Vinted Messages] Chargement d√©j√† en cours, skip");
      return;
    }
    
    isMessagesLoading = true;
    
    const messagesContainer = document.getElementById('vinted-messages-list');
    if (messagesContainer) {
      // Ne pas afficher "Chargement..." si c'est un rafra√Æchissement automatique
      const isLoading = !messagesContainer.querySelector('.message-item');
      if (isLoading) {
        messagesContainer.innerHTML = '<p class="messages-loading">Chargement...</p>';
      }
    }
  
    try {
      const data = await fetchInbox(page, 20);
      if (data && data.conversations) {
        // Filtrer les messages selon le statut lu/non lu
        let filteredConversations = data.conversations;
        if (readFilter === 'unread') {
          filteredConversations = data.conversations.filter(conv => conv.unread === true);
        } else if (readFilter === 'read') {
          filteredConversations = data.conversations.filter(conv => conv.unread !== true);
        }
        
        // Limiter le nombre de conversations affich√©es pour r√©duire la m√©moire
        const MAX_DISPLAYED_CONVERSATIONS = 30;
        filteredConversations = filteredConversations.slice(0, MAX_DISPLAYED_CONVERSATIONS);
        
        renderMessagesList(filteredConversations, readFilter);
        currentMessagesFilter = readFilter;
        currentMessagesPage = page;
        
        // Mettre √† jour les boutons de filtre avec les compteurs
        updateMessagesFilterButtons(readFilter, data.conversations);
        
        // Mettre √† jour le compteur dans l'onglet avec les donn√©es d√©j√† charg√©es
        updateMessagesCountInTab(data.conversations);
      } else {
        if (messagesContainer) {
          messagesContainer.innerHTML = '<p class="messages-empty">Erreur lors du chargement des messages</p>';
        }
        // Mettre √† jour les boutons sans compteurs en cas d'erreur
        updateMessagesFilterButtons(readFilter);
      }
    } catch (error) {
      console.error("[Vinted Messages] Erreur lors du chargement des messages:", error);
      if (messagesContainer) {
        messagesContainer.innerHTML = '<p class="messages-empty">Erreur lors du chargement des messages</p>';
      }
    } finally {
      isMessagesLoading = false;
    }
  }
  
  /**
   * D√©marre le rafra√Æchissement automatique des messages toutes les 5 secondes
   */
  let isMessagesLoading = false;
  
  let isMessagesAutoRefreshStarting = false;
  
  async function startMessagesAutoRefresh() {
    // √âviter les appels multiples simultan√©s
    if (isMessagesAutoRefreshStarting) {
      console.log("[Vinted Messages] D√©marrage d√©j√† en cours, skip");
      return;
    }
    
    // Arr√™ter l'intervalle existant s'il y en a un
    stopMessagesAutoRefresh();
    
    isMessagesAutoRefreshStarting = true;
    
    // Rafra√Æchir imm√©diatement
    loadMessages(currentMessagesFilter, currentMessagesPage);
    
    // Obtenir l'intervalle depuis les settings ou la config
    const getMessagesInterval = async () => {
      if (typeof getInterval === 'function') {
        return await getInterval('messages');
      }
      return CONFIG.MESSAGES_REFRESH_INTERVAL || 10000;
    };
    
    const interval = await getMessagesInterval();
    
    // S'assurer qu'on ne cr√©e pas plusieurs intervalles
    if (messagesRefreshInterval) {
      clearInterval(messagesRefreshInterval);
      messagesRefreshInterval = null;
    }
    
    // Puis rafra√Æchir selon l'intervalle configur√©
    messagesRefreshInterval = setInterval(async () => {
      // √âviter les appels multiples si une requ√™te est d√©j√† en cours
      if (isMessagesLoading) {
        console.log("[Vinted Messages] Requ√™te en cours, skip du rafra√Æchissement");
        return;
      }
      
      console.log("[Vinted Messages] Rafra√Æchissement automatique de la liste des messages");
      loadMessages(currentMessagesFilter, currentMessagesPage);
      // Le compteur sera mis √† jour par loadMessages avec les donn√©es d√©j√† charg√©es
    }, interval);
    
    console.log(`[Vinted Messages] ‚úÖ Rafra√Æchissement automatique activ√© (toutes les ${interval / 1000} secondes)`);
    isMessagesAutoRefreshStarting = false;
  }
  
  /**
   * Arr√™te le rafra√Æchissement automatique des messages
   */
  function stopMessagesAutoRefresh() {
    if (messagesRefreshInterval) {
      clearInterval(messagesRefreshInterval);
      messagesRefreshInterval = null;
      console.log("[Vinted Messages] Rafra√Æchissement automatique arr√™t√©");
    }
  }
  
  function updateMessagesFilterButtons(activeFilter, conversations = null) {
    const buttons = document.querySelectorAll('.message-filter-btn');
    
    // Calculer les compteurs si les conversations sont fournies
    let counts = { all: 0, unread: 0, read: 0 };
    if (conversations) {
      counts.all = conversations.length;
      counts.unread = conversations.filter(conv => conv.unread === true).length;
      counts.read = conversations.filter(conv => conv.unread !== true).length;
    }
    
    // Mapping des textes de base
    const baseTexts = {
      'all': 'Tous',
      'unread': 'Non lus',
      'read': 'Lus'
    };
    
    buttons.forEach(btn => {
      const filter = btn.dataset.filter;
      if (filter === activeFilter) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
      
      // Mettre √† jour le texte avec le compteur
      if (conversations) {
        const baseText = baseTexts[filter] || filter;
        btn.textContent = `${baseText} (${counts[filter] || 0})`;
      }
    });
  }
  
  let messagesListManagerRetries = 0;
  const MAX_MESSAGES_RETRIES = 10;
  
  let isCreatingMessagesManager = false;
  
  function createMessagesListManager() {
    // √âviter les appels multiples simultan√©s
    if (isCreatingMessagesManager) {
      console.log("[Messages] Cr√©ation d√©j√† en cours, skip");
      return;
    }
    
    const sidebar = document.getElementById('sidebar');
    if (!sidebar) {
      messagesListManagerRetries++;
      if (messagesListManagerRetries < MAX_MESSAGES_RETRIES) {
        setTimeout(createMessagesListManager, 500);
      }
      return;
    }
  
    if (document.getElementById('vinted-messages-list-manager')) {
      console.log("[Messages] Manager d√©j√† cr√©√©, skip");
      return; // D√©j√† cr√©√©
    }
    
    isCreatingMessagesManager = true;
  
    const messagesManager = document.createElement('div');
    messagesManager.id = 'vinted-messages-list-manager';
    messagesManager.className = 'vinted-messages-list-manager';
    messagesManager.style.display = 'none'; // Masqu√© par d√©faut
    messagesManager.innerHTML = `
      <div class="vinted-messages-list-manager-header">
        <h3 class="vinted-messages-list-manager-title">Mes Messages</h3>
      </div>
      <div class="vinted-messages-filters">
        <button class="message-filter-btn active" data-filter="all" title="Tous les messages">Tous</button>
        <button class="message-filter-btn" data-filter="unread" title="Messages non lus">Non lus</button>
        <button class="message-filter-btn" data-filter="read" title="Messages lus">Lus</button>
      </div>
      <div id="vinted-messages-list" class="vinted-messages-list">
        <p class="messages-loading">Chargement...</p>
      </div>
    `;
  
    // Ins√©rer dans le sticky container apr√®s le manager de messages notifications
    const sidebarStickyContainer = document.getElementById('sidebar-sticky-container');
    const messagesStickyContainer = document.getElementById('messages-sticky-container');
    
    if (sidebarStickyContainer) {
      if (messagesStickyContainer) {
        // Ins√©rer apr√®s le messages-sticky-container
        if (messagesStickyContainer.nextSibling) {
          sidebarStickyContainer.insertBefore(messagesManager, messagesStickyContainer.nextSibling);
        } else {
          sidebarStickyContainer.appendChild(messagesManager);
        }
      } else {
        // Si pas de messages sticky container, ins√©rer avant le orders-manager
        const ordersManager = document.getElementById('vinted-orders-manager');
        if (ordersManager && ordersManager.parentNode) {
          ordersManager.parentNode.insertBefore(messagesManager, ordersManager);
        } else {
          sidebarStickyContainer.appendChild(messagesManager);
        }
      }
    } else {
      sidebar.insertBefore(messagesManager, sidebar.firstChild);
    }
  
    // Boutons de filtre - utiliser la d√©l√©gation d'√©v√©nements
    messagesManager.addEventListener('click', (e) => {
      const filterBtn = e.target.closest('.message-filter-btn');
      if (filterBtn) {
        const filter = filterBtn.dataset.filter;
        loadMessages(filter, 1);
      }
    });
    
    // D√©l√©gation d'√©v√©nements pour les clics sur les conversations
    const messagesList = messagesManager.querySelector('#vinted-messages-list');
    if (messagesList) {
      messagesList.addEventListener('click', (e) => {
        const messageItem = e.target.closest('.message-item');
        if (!messageItem) return;
        
        // Ne pas ouvrir si on clique sur le lien externe
        if (e.target.closest('.message-link')) {
          return;
        }
        
        const conversationId = messageItem.dataset.conversationId;
        if (conversationId) {
          openConversationModal(conversationId);
        }
      });
    }
  
    // Charger les messages initiaux et d√©marrer le rafra√Æchissement automatique
    loadMessages('all', 1);
    
    // D√©marrer le rafra√Æchissement automatique imm√©diatement (l'onglet messages est actif par d√©faut)
    setTimeout(async () => {
      if (typeof startMessagesAutoRefresh === 'function') {
        await startMessagesAutoRefresh();
      }
    }, 500);
    
    console.log("[Messages List Manager] Interface cr√©√©e avec succ√®s");
    messagesListManagerRetries = 0;
    isCreatingMessagesManager = false;
  }
  
  // Injecter les styles pour la modal de conversation si n√©cessaire
  function ensureConversationModalStyles() {
    if (document.getElementById('vinted-conversation-modal-styles')) {
      return; // Styles d√©j√† inject√©s
    }
    
    const style = document.createElement('style');
    style.id = 'vinted-conversation-modal-styles';
    style.textContent = `
      .vinted-conversation-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 100000;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(4px);
        animation: fadeIn 0.3s ease;
      }
      
      .vinted-conversation-container {
        width: 90%;
        max-width: 600px;
        max-height: 90vh;
        background: rgba(255, 255, 255, 0.95) !important;
        background-color: rgba(255, 255, 255, 0.95) !important;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        animation: slideUp 0.3s ease;
      }
      
      .vinted-dark-mode .vinted-conversation-container {
        background: rgba(30, 30, 30, 0.95) !important;
        background-color: rgba(30, 30, 30, 0.95) !important;
      }
      
      .vinted-conversation-content {
        display: flex;
        flex-direction: column;
        height: 100%;
        max-height: 90vh;
      }
      
      .vinted-conversation-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 1rem 1.5rem;
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      }
      
      .vinted-conversation-user {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }
      
      .vinted-conversation-avatar {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        object-fit: cover;
      }
      
      .vinted-conversation-user-info {
        display: flex;
        flex-direction: column;
      }
      
      .vinted-conversation-username {
        font-weight: 600;
        font-size: 1rem;
        color: #1a1a1a;
      }
      
      .vinted-dark-mode .vinted-conversation-username {
        color: #ffffff;
      }
      
      .vinted-conversation-subtitle {
        font-size: 0.875rem;
        color: #666;
        margin-top: 0.25rem;
      }
      
      .vinted-dark-mode .vinted-conversation-subtitle {
        color: #aaa;
      }
      
      .vinted-conversation-close {
        background: transparent;
        border: none;
        font-size: 2rem;
        line-height: 1;
        color: #666;
        cursor: pointer;
        padding: 0;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s;
      }
      
      .vinted-conversation-close:hover {
        background: rgba(0, 0, 0, 0.1);
        color: #333;
      }
      
      .vinted-dark-mode .vinted-conversation-close {
        color: #aaa;
      }
      
      .vinted-dark-mode .vinted-conversation-close:hover {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
      }
      
      .vinted-conversation-messages {
        flex: 1;
        overflow-y: auto;
        padding: 1rem 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      
      .vinted-notif-messages-content {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      
      .vinted-notif-messages-input-container {
        margin-top: 12px;
        padding: 1rem 1.5rem;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
        display: flex;
        gap: 8px;
        align-items: center;
      }
      
      .vinted-offer-form-container {
        padding: 1rem 1.5rem;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
        background: rgba(249, 250, 251, 0.5);
      }
      
      .vinted-dark-mode .vinted-offer-form-container {
        background: rgba(30, 30, 30, 0.5);
        border-top-color: rgba(255, 255, 255, 0.1);
      }
      
      .vinted-offer-form-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
      }
      
      .vinted-offer-form-header h3 {
        margin: 0;
        font-size: 1.125rem;
        font-weight: 600;
        color: #1a1a1a;
      }
      
      .vinted-dark-mode .vinted-offer-form-header h3 {
        color: #ffffff;
      }
      
      .vinted-offer-form-close {
        background: transparent;
        border: none;
        font-size: 1.5rem;
        line-height: 1;
        color: #666;
        cursor: pointer;
        padding: 0;
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s;
      }
      
      .vinted-offer-form-close:hover {
        background: rgba(0, 0, 0, 0.1);
        color: #333;
      }
      
      .vinted-dark-mode .vinted-offer-form-close {
        color: #aaa;
      }
      
      .vinted-dark-mode .vinted-offer-form-close:hover {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
      }
      
      .vinted-offer-form-body {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      
      .vinted-offer-form-body label {
        font-weight: 500;
        font-size: 0.875rem;
        color: #1a1a1a;
      }
      
      .vinted-dark-mode .vinted-offer-form-body label {
        color: #ffffff;
      }
      
      .vinted-offer-price-input {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid #ddd;
        border-radius: 8px;
        font-size: 1rem;
        box-sizing: border-box;
        background: white;
        color: #1a1a1a;
      }
      
      .vinted-offer-price-input:focus {
        outline: none;
        border-color: #09B1BA;
        box-shadow: 0 0 0 3px rgba(9, 177, 186, 0.1);
      }
      
      .vinted-dark-mode .vinted-offer-price-input {
        background: #2a2a2a;
        border-color: #444;
        color: white;
      }
      
      .vinted-offer-form-actions {
        display: flex;
        gap: 0.75rem;
        justify-content: flex-end;
      }
      
      .vinted-offer-form-cancel,
      .vinted-offer-form-submit {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 8px;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .vinted-offer-form-cancel {
        background: #f0f0f0;
        color: #333;
      }
      
      .vinted-offer-form-cancel:hover {
        background: #e0e0e0;
      }
      
      .vinted-dark-mode .vinted-offer-form-cancel {
        background: #333;
        color: white;
      }
      
      .vinted-dark-mode .vinted-offer-form-cancel:hover {
        background: #444;
      }
      
      .vinted-offer-form-submit {
        background: #09B1BA;
        color: white;
      }
      
      .vinted-offer-form-submit:hover {
        background: #078a91;
      }
      
      .vinted-offer-form-submit:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      
      .vinted-notif-messages-input {
        flex: 1;
        padding: 8px 12px;
        border: 1px solid rgba(0, 0, 0, 0.2);
        border-radius: 20px;
        font-size: 0.875rem;
        background: rgba(255, 255, 255, 0.5);
        color: #1a1a1a;
        outline: none;
        transition: all 0.2s;
      }
      
      .vinted-notif-messages-input:focus {
        border-color: #09B1BA;
        background: rgba(255, 255, 255, 0.8);
        box-shadow: 0 0 0 2px rgba(9, 177, 186, 0.2);
      }
      
      .vinted-notif-messages-send {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: #09B1BA;
        border: none;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        flex-shrink: 0;
      }
      
      .vinted-notif-messages-send:hover:not(:disabled) {
        background: #078a91;
        transform: scale(1.05);
      }
      
      .vinted-notif-offer-btn {
        margin: 12px 1.5rem;
        padding: 8px 16px;
        background: #09B1BA;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.875rem;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: all 0.2s;
      }
      
      .vinted-notif-offer-btn:hover {
        background: #078a91;
        transform: translateY(-1px);
      }
      
      .vinted-conversation-footer {
        padding: 1rem 1.5rem;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
        text-align: center;
      }
      
      .vinted-conversation-link {
        color: #09B1BA;
        text-decoration: none;
        font-weight: 500;
        transition: all 0.2s;
      }
      
      .vinted-conversation-link:hover {
        color: #078a91;
        text-decoration: underline;
      }
      
      .vinted-conversation-loading {
        padding: 2rem;
        text-align: center;
        color: #666;
      }
      
      .vinted-msg-item {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        max-width: 70%;
      }
      
      .vinted-msg-current-user {
        align-self: flex-end;
        align-items: flex-end;
      }
      
      .vinted-msg-other-user {
        align-self: flex-start;
        align-items: flex-start;
      }
      
      .vinted-msg-body {
        padding: 0.75rem 1rem;
        border-radius: 12px;
        background: #f0f0f0;
        color: #1a1a1a;
        word-wrap: break-word;
      }
      
      .vinted-msg-current-user .vinted-msg-body {
        background: #09B1BA;
        color: white;
      }
      
      .vinted-dark-mode .vinted-msg-other-user .vinted-msg-body {
        background: #2a2a2a;
        color: #e0e0e0;
      }
      
      .vinted-msg-time {
        font-size: 0.75rem;
        color: #999;
        margin-top: 0.25rem;
      }
      
      .vinted-dark-mode .vinted-msg-time {
        color: #666;
      }
      
      .vinted-msg-offer {
        padding: 0.75rem 1rem;
        border-radius: 12px;
        background: #fff3cd;
        border: 1px solid #ffc107;
        color: #856404;
      }
      
      .vinted-msg-offer.accepted {
        background: #d4edda;
        border-color: #28a745;
        color: #155724;
      }
      
      .vinted-msg-current-user .vinted-msg-offer {
        background: #09B1BA;
        border-color: #078a91;
        color: white;
      }
      
      .vinted-msg-current-user .vinted-msg-offer.accepted {
        background: #28a745;
        border-color: #1e7e34;
        color: white;
      }
      
      .vinted-dark-mode .vinted-msg-offer {
        background: #3d2f00;
        border-color: #ffc107;
        color: #ffc107;
      }
      
      .vinted-dark-mode .vinted-msg-offer.accepted {
        background: #1e4620;
        border-color: #28a745;
        color: #28a745;
      }
      
      .vinted-msg-offer-title {
        font-weight: 600;
        margin-bottom: 0.5rem;
        font-size: 0.875rem;
      }
      
      .vinted-msg-offer-price {
        font-size: 1.125rem;
        font-weight: 700;
        margin-bottom: 0.25rem;
      }
      
      .vinted-msg-offer-original {
        font-size: 0.75rem;
        opacity: 0.8;
        text-decoration: line-through;
      }
      
      .vinted-msg-status,
      .vinted-msg-action {
        padding: 0.75rem 1rem;
        border-radius: 12px;
        background: #e9ecef;
        color: #495057;
        text-align: center;
      }
      
      .vinted-dark-mode .vinted-msg-status,
      .vinted-dark-mode .vinted-msg-action {
        background: #2a2a2a;
        color: #e0e0e0;
      }
      
      .vinted-msg-status-title,
      .vinted-msg-action-title {
        font-weight: 600;
        margin-bottom: 0.25rem;
      }
      
      .vinted-msg-status-subtitle,
      .vinted-msg-action-subtitle {
        font-size: 0.875rem;
        opacity: 0.8;
      }
      
      .vinted-msg-actions {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.5rem;
        justify-content: center;
      }
      
      .vinted-msg-action-btn {
        padding: 0.5rem 1rem;
        background: #09B1BA;
        color: white;
        border-radius: 6px;
        text-decoration: none;
        font-size: 0.875rem;
        transition: all 0.2s;
      }
      
      .vinted-msg-action-btn:hover {
        background: #078a91;
      }
      
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      
      @keyframes slideUp {
        from {
          transform: translateY(20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
      
      .vinted-offer-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 20000;
        animation: fadeIn 0.2s ease;
      }
      
      .vinted-offer-modal-content {
        background: rgba(255, 255, 255, 0.95) !important;
        background-color: rgba(255, 255, 255, 0.95) !important;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-radius: 12px;
        width: 90%;
        max-width: 400px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        animation: slideUp 0.3s ease;
      }
      
      .vinted-dark-mode .vinted-offer-modal-content {
        background: rgba(30, 30, 30, 0.95) !important;
        background-color: rgba(30, 30, 30, 0.95) !important;
        color: white;
      }
      
      .vinted-offer-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1.5rem;
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      }
      
      .vinted-dark-mode .vinted-offer-modal-header {
        border-bottom-color: rgba(255, 255, 255, 0.1);
      }
      
      .vinted-offer-modal-header h3 {
        margin: 0;
        font-size: 1.25rem;
        font-weight: 600;
      }
      
      .vinted-offer-modal-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: #666;
        padding: 0;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        transition: all 0.2s;
      }
      
      .vinted-offer-modal-close:hover {
        background: rgba(0, 0, 0, 0.1);
        color: #000;
      }
      
      .vinted-dark-mode .vinted-offer-modal-close {
        color: #aaa;
      }
      
      .vinted-dark-mode .vinted-offer-modal-close:hover {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
      }
      
      .vinted-offer-modal-body {
        padding: 1.5rem;
      }
      
      .vinted-offer-modal-body label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 500;
        font-size: 0.875rem;
      }
      
      .vinted-offer-price-input {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid #ddd;
        border-radius: 8px;
        font-size: 1rem;
        margin-bottom: 1.5rem;
        box-sizing: border-box;
      }
      
      .vinted-offer-price-input:focus {
        outline: none;
        border-color: #09B1BA;
        box-shadow: 0 0 0 3px rgba(9, 177, 186, 0.1);
      }
      
      .vinted-dark-mode .vinted-offer-price-input {
        background: #2a2a2a;
        border-color: #444;
        color: white;
      }
      
      .vinted-offer-modal-actions {
        display: flex;
        gap: 0.75rem;
        justify-content: flex-end;
      }
      
      .vinted-offer-modal-cancel,
      .vinted-offer-modal-submit {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 8px;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .vinted-offer-modal-cancel {
        background: #f0f0f0;
        color: #333;
      }
      
      .vinted-offer-modal-cancel:hover {
        background: #e0e0e0;
      }
      
      .vinted-dark-mode .vinted-offer-modal-cancel {
        background: #333;
        color: white;
      }
      
      .vinted-dark-mode .vinted-offer-modal-cancel:hover {
        background: #444;
      }
      
      .vinted-offer-modal-submit {
        background: #09B1BA;
        color: white;
      }
      
      .vinted-offer-modal-submit:hover {
        background: #078a91;
      }
      
      .vinted-offer-modal-submit:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
    `;
    
    document.head.appendChild(style);
  }
  
  // Ouvrir une modal de conversation compl√®te
  async function openConversationModal(conversationId) {
    try {
      // S'assurer que les styles sont inject√©s
      ensureConversationModalStyles();
      
      // Cr√©er la modal
      let modal = document.createElement('div');
      modal.className = 'vinted-conversation-modal';
      modal.innerHTML = `
        <div class="vinted-conversation-container">
          <div class="vinted-conversation-content">
            <div class="vinted-conversation-loading">Chargement...</div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Charger la conversation
      const conversation = await fetchConversation(conversationId);
      
      // D√©terminer l'ID de l'utilisateur actuel
      const oppositeUserId = conversation.opposite_user.id;
      let currentUserId = oppositeUserId;
      for (const msg of conversation.messages) {
        if (msg.entity_type === 'message' && msg.entity?.user_id && msg.entity.user_id !== oppositeUserId) {
          currentUserId = msg.entity.user_id;
          break;
        }
      }
      
      // Construire le HTML de la conversation
      const conversationUrl = conversation.conversation_url || `https://www.vinted.fr/inbox/${conversationId}`;
      const transaction = conversation.transaction || null;
      // Trier les messages par date (du plus ancien au plus r√©cent)
      const sortedMessages = [...(conversation.messages || [])].sort((a, b) => {
        const dateA = a.created_at_ts ? new Date(a.created_at_ts).getTime() : 0;
        const dateB = b.created_at_ts ? new Date(b.created_at_ts).getTime() : 0;
        return dateA - dateB;
      });
      
      const messagesHtml = sortedMessages.map(msg => formatMessage(msg, currentUserId, conversationUrl, transaction)).join('');
      
      // V√©rifier si une transaction existe pour afficher le bouton d'offre
      const hasTransaction = transaction && transaction.id;
      const offerButtonHtml = hasTransaction ? `
        <button class="vinted-notif-offer-btn" aria-label="Faire une offre">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="12" y1="1" x2="12" y2="23"></line>
            <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>
          </svg>
          Faire une offre
        </button>
      ` : '';
      
      const modalContent = modal.querySelector('.vinted-conversation-content');
      modalContent.innerHTML = `
        <div class="vinted-conversation-header">
          <div class="vinted-conversation-user">
            <img src="${conversation.opposite_user.photo?.thumbnails?.find(t => t.type === "thumb100")?.url || conversation.opposite_user.photo?.url || 'https://via.placeholder.com/50'}" 
                 alt="${escapeHtml(conversation.opposite_user.login)}"
                 class="vinted-conversation-avatar">
            <div class="vinted-conversation-user-info">
              <div class="vinted-conversation-username">${escapeHtml(conversation.opposite_user.login)}</div>
              ${conversation.subtitle ? `<div class="vinted-conversation-subtitle">${escapeHtml(conversation.subtitle)}</div>` : ''}
            </div>
          </div>
          <button class="vinted-conversation-close" aria-label="Fermer">√ó</button>
        </div>
        <div class="vinted-conversation-messages">
          <div class="vinted-notif-messages-content">
            ${messagesHtml}
          </div>
          ${offerButtonHtml}
        </div>
        <div class="vinted-offer-form-container" style="display: none;">
          <div class="vinted-offer-form-header">
            <h3>Faire une offre</h3>
            <button class="vinted-offer-form-close" aria-label="Fermer">√ó</button>
          </div>
          <div class="vinted-offer-form-body">
            <label for="vinted-offer-price">Prix (EUR)</label>
            <input type="number" 
                   id="vinted-offer-price" 
                   class="vinted-offer-price-input" 
                   placeholder="0.00" 
                   step="0.01" 
                   min="0.01"
                   required>
            <div class="vinted-offer-form-actions">
              <button class="vinted-offer-form-cancel">Annuler</button>
              <button class="vinted-offer-form-submit">Envoyer l'offre</button>
            </div>
          </div>
        </div>
        <div class="vinted-notif-messages-input-container">
          <input type="text" 
                 class="vinted-notif-messages-input" 
                 placeholder="Tapez votre message..."
                 maxlength="1000">
          <button class="vinted-notif-messages-send" aria-label="Envoyer">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="22" y1="2" x2="11" y2="13"></line>
              <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
            </svg>
          </button>
        </div>
        <div class="vinted-conversation-footer">
          <a href="${conversation.conversation_url}" target="_blank" class="vinted-conversation-link">
            Ouvrir sur Vinted ‚Üí
          </a>
        </div>
      `;
      
      let messagesContainer = modal.querySelector('.vinted-conversation-messages');
      let input = modal.querySelector('.vinted-notif-messages-input');
      let sendBtn = modal.querySelector('.vinted-notif-messages-send');
      
      // Gestionnaire d'envoi de message
      const handleSend = async () => {
        const messageText = input.value.trim();
        if (!messageText) return;
        
        input.disabled = true;
        sendBtn.disabled = true;
        sendBtn.style.opacity = '0.5';
        
        try {
          await sendMessage(conversationId, messageText);
          input.value = '';
          
          // Recharger la conversation
          const updatedConversation = await fetchConversation(conversationId);
          const oppositeUserId = updatedConversation.opposite_user.id;
          let currentUserId = oppositeUserId;
          for (const msg of updatedConversation.messages) {
            if (msg.entity_type === 'message' && msg.entity?.user_id && msg.entity.user_id !== oppositeUserId) {
              currentUserId = msg.entity.user_id;
              break;
            }
          }
          
          const updatedMessagesHtml = updatedConversation.messages.map(msg => 
            formatMessage(msg, currentUserId, conversationUrl, transaction)
          ).join('');
          
          const messagesContent = messagesContainer.querySelector('.vinted-notif-messages-content');
          messagesContent.innerHTML = updatedMessagesHtml;
          
          setTimeout(() => {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
          }, 100);
        } catch (error) {
          console.error("[Messages] Erreur lors de l'envoi:", error);
          alert("Erreur lors de l'envoi du message. Veuillez r√©essayer.");
        } finally {
          input.disabled = false;
          sendBtn.disabled = false;
          sendBtn.style.opacity = '1';
          input.focus();
        }
      };
      
      sendBtn.addEventListener('click', handleSend);
      const inputKeyHandler = (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          handleSend();
        }
      };
      input.addEventListener('keypress', inputKeyHandler);
      
      // Gestionnaire pour le bouton d'offre
      if (hasTransaction) {
        const offerBtn = modal.querySelector('.vinted-notif-offer-btn');
        const offerFormContainer = modal.querySelector('.vinted-offer-form-container');
        const offerFormClose = modal.querySelector('.vinted-offer-form-close');
        const offerFormCancel = modal.querySelector('.vinted-offer-form-cancel');
        const messageInputContainer = modal.querySelector('.vinted-notif-messages-input-container');
        
        if (offerBtn) {
          offerBtn.addEventListener('click', () => {
            // Afficher le formulaire d'offre et masquer l'input de message
            offerFormContainer.style.display = 'block';
            messageInputContainer.style.display = 'none';
            const priceInput = modal.querySelector('#vinted-offer-price');
            setTimeout(() => priceInput?.focus(), 100);
          });
        }
        
        // Fermer le formulaire d'offre
        if (offerFormClose) {
          offerFormClose.addEventListener('click', () => {
            offerFormContainer.style.display = 'none';
            messageInputContainer.style.display = 'flex';
          });
        }
        
        if (offerFormCancel) {
          offerFormCancel.addEventListener('click', () => {
            offerFormContainer.style.display = 'none';
            messageInputContainer.style.display = 'flex';
          });
        }
        
        // Gestionnaire pour soumettre l'offre
        const offerFormSubmit = modal.querySelector('.vinted-offer-form-submit');
        if (offerFormSubmit) {
          offerFormSubmit.addEventListener('click', async () => {
            const priceInput = modal.querySelector('#vinted-offer-price');
            const price = priceInput.value.trim();
            
            if (!price || parseFloat(price) <= 0) {
              alert('Veuillez entrer un prix valide');
              return;
            }
            
            offerFormSubmit.disabled = true;
            offerFormSubmit.textContent = 'Envoi...';
            
            try {
              await sendOfferRequest(transaction.id, price, 'EUR');
              
              // Recharger la conversation
              const updatedConversation = await fetchConversation(conversationId);
              const oppositeUserId = updatedConversation.opposite_user.id;
              let currentUserId = oppositeUserId;
              for (const msg of updatedConversation.messages) {
                if (msg.entity_type === 'message' && msg.entity?.user_id && msg.entity.user_id !== oppositeUserId) {
                  currentUserId = msg.entity.user_id;
                  break;
                }
              }
              
              const conversationUrl = updatedConversation.conversation_url || `https://www.vinted.fr/inbox/${conversationId}`;
              const updatedTransaction = updatedConversation.transaction || transaction;
              const updatedMessagesHtml = updatedConversation.messages.map(msg => 
                formatMessage(msg, currentUserId, conversationUrl, updatedTransaction)
              ).join('');
              
              const messagesContent = messagesContainer.querySelector('.vinted-notif-messages-content');
              messagesContent.innerHTML = updatedMessagesHtml;
              
              // Masquer le formulaire et r√©afficher l'input de message
              offerFormContainer.style.display = 'none';
              messageInputContainer.style.display = 'flex';
              priceInput.value = '';
              
              setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
              }, 100);
            } catch (error) {
              console.error("[Messages] Erreur lors de l'envoi de l'offre:", error);
              alert("Erreur lors de l'envoi de l'offre. Veuillez r√©essayer.");
              offerFormSubmit.disabled = false;
              offerFormSubmit.textContent = 'Envoyer l\'offre';
            }
          });
        }
        
        // Permettre d'envoyer l'offre avec Enter
        const priceInput = modal.querySelector('#vinted-offer-price');
        if (priceInput) {
          priceInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              offerFormSubmit?.click();
            }
          });
        }
      }
      
      // Gestionnaire pour fermer la modal
      const closeBtn = modal.querySelector('.vinted-conversation-close');
      let isClosing = false;
      const closeModal = () => {
        if (isClosing) return;
        isClosing = true;
        
        // Nettoyer imm√©diatement les event listeners et r√©f√©rences
        document.removeEventListener('keydown', escapeHandler);
        sendBtn.removeEventListener('click', handleSend);
        input.removeEventListener('keypress', inputKeyHandler);
        
        // Nettoyer le contenu pour lib√©rer la m√©moire
        const messagesContent = messagesContainer?.querySelector('.vinted-notif-messages-content');
        if (messagesContent) messagesContent.innerHTML = '';
        
        modal.style.opacity = '0';
        setTimeout(() => {
          modal.remove();
          // Forcer le garbage collection en vidant les r√©f√©rences
          modal = null;
          messagesContainer = null;
          input = null;
          sendBtn = null;
        }, 100); // R√©duire le d√©lai pour lib√©rer plus rapidement
      };
      
      closeBtn.addEventListener('click', closeModal);
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeModal();
        }
      });
      
      // Fermer avec Escape
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          closeModal();
        }
      };
      document.addEventListener('keydown', escapeHandler);
      
      // Faire d√©filer vers le bas et focus sur l'input
      setTimeout(() => {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        input.focus();
      }, 100);
      
    } catch (error) {
      console.error("[Messages] Erreur lors de l'affichage de la conversation:", error);
      alert("Erreur lors du chargement de la conversation. Veuillez r√©essayer.");
    }
  }
  
  // Fonction showOfferDialog supprim√©e - le formulaire d'offre est maintenant int√©gr√© dans la modal de conversation

  // ==========================================
  // offer.js
  // ==========================================
  
  // ==================== OFFER OPTIONS ====================
  let cachedInboxData = null;
  let cachedInboxTime = 0;
  const INBOX_CACHE_DURATION = 5000; // 5 secondes de cache
  
  /**
   * R√©cup√®re l'ID de l'utilisateur connect√©
   * @returns {Promise<string|null>} - User ID ou null
   */
  async function getUserId() {
    // Utiliser le cache si disponible
    if (cachedUserId) {
      return cachedUserId;
    }
    
    // M√©thode 1: Essayer de r√©cup√©rer depuis la page actuelle
    try {
      const scripts = document.querySelectorAll('script:not([src])');
      for (const script of scripts) {
        const content = script.textContent || '';
        const patterns = [
          /"user_id"\s*:\s*(\d+)/,
          /"id"\s*:\s*(\d+).*"login"/,
          /"current_user_id"\s*:\s*(\d+)/,
          /userId["\s]*[:=]\s*["']?(\d+)/i,
        ];
        
        for (const pattern of patterns) {
          const match = content.match(pattern);
          if (match && match[1]) {
            const userId = String(match[1]);
            console.log("[Offer] User ID trouv√© depuis la page:", userId);
            cachedUserId = userId;
            return userId;
          }
        }
      }
    } catch (error) {
      console.warn("[Offer] Erreur lors de l'extraction du userId depuis la page:", error);
    }
    
    // M√©thode 2: Essayer depuis les cookies
    try {
      const cookies = document.cookie.split(';');
      for (const cookie of cookies) {
        const [name, value] = cookie.trim().split('=');
        if (name === 'user_id' || name === 'userId') {
          if (value) {
            console.log("[Offer] User ID trouv√© depuis les cookies:", value);
            cachedUserId = value;
            return value;
          }
        }
      }
    } catch (error) {
      console.warn("[Offer] Erreur lors de la r√©cup√©ration du userId depuis les cookies:", error);
    }
    
    // M√©thode 3: Utiliser l'inbox SANS charger les conversations individuelles
    // On essaie de trouver le userId dans les donn√©es de l'inbox directement
    try {
      const response = await fetch('https://www.vinted.fr/api/v2/inbox?page=1&per_page=20', {
        credentials: 'include',
        headers: {
          'accept': 'application/json, text/plain, */*',
          'accept-language': 'fr',
        }
      });
  
      if (response.ok) {
        const data = await response.json();
        // Mettre en cache
        cachedInboxData = data;
        cachedInboxTime = Date.now();
        
        // Chercher le userId dans les donn√©es de l'inbox sans charger les conversations
        // L'inbox peut contenir des informations sur le dernier message
        if (data.conversations && data.conversations.length > 0) {
          for (const conversation of data.conversations) {
            // V√©rifier si on a des informations sur le dernier message
            if (conversation.last_message && conversation.last_message.user_id) {
              const userId = String(conversation.last_message.user_id);
              console.log("[Offer] User ID trouv√© via inbox (last_message):", userId);
              cachedUserId = userId;
              return userId;
            }
          }
        }
      }
    } catch (error) {
      console.error("[Offer] Erreur lors de la r√©cup√©ration via API inbox:", error);
    }
    
    // Dernier recours: NE PAS charger les conversations individuelles
    // On retourne null et on laisse l'utilisateur g√©rer
    console.warn("[Offer] User ID non trouv√© - les conversations individuelles ne seront PAS charg√©es");
    return null;
  }
  
  // Cache pour le seller_id et le userId pour √©viter les requ√™tes r√©p√©t√©es
  let cachedSellerId = null;
  let cachedUserId = null;
  
  // Partager le cache du userId avec wallet.js
  if (!window.cachedGlobalUserId && cachedUserId) {
    window.cachedGlobalUserId = cachedUserId;
  }
  
  /**
   * R√©cup√®re un seller_id depuis la page actuelle ou depuis les conversations
   * @returns {Promise<number|null>} - Seller ID ou null
   */
  async function getSellerIdForOfferOptions() {
    // Utiliser le cache si disponible
    if (cachedSellerId) {
      return cachedSellerId;
    }
    
    // R√©cup√©rer le userId une seule fois (avec cache)
    if (!cachedUserId) {
      cachedUserId = await getUserId();
    }
    
    // M√©thode 1: Essayer de r√©cup√©rer depuis la page actuelle (si on est sur une page d'item)
    try {
      const scripts = document.querySelectorAll('script:not([src])');
      for (const script of scripts) {
        const content = script.textContent || '';
        const patterns = [
          /"seller_id"\s*:\s*(\d+)/,
          /"user_id"\s*:\s*(\d+)/,
          /"user"\s*:\s*\{[^}]*"id"\s*:\s*(\d+)/,
        ];
        
        for (const pattern of patterns) {
          const match = content.match(pattern);
          if (match && match[1]) {
            const sellerId = parseInt(match[1]);
            // V√©rifier que ce n'est pas notre propre ID
            if (cachedUserId && sellerId !== parseInt(cachedUserId)) {
              cachedSellerId = sellerId;
              return sellerId;
            }
          }
        }
      }
    } catch (error) {
      console.warn("[Offer] Erreur lors de l'extraction du seller_id depuis la page:", error);
    }
  
    // M√©thode 2: R√©cup√©rer depuis les conversations (opposite_user) - utiliser le cache si disponible
    const now = Date.now();
    if (cachedInboxData && (now - cachedInboxTime) < INBOX_CACHE_DURATION) {
      const data = cachedInboxData;
      if (data.conversations && data.conversations.length > 0) {
        // Prendre le premier opposite_user qui n'est pas nous
        for (const conversation of data.conversations) {
          if (conversation.opposite_user && conversation.opposite_user.id) {
            const oppositeUserId = parseInt(conversation.opposite_user.id);
            if (cachedUserId && oppositeUserId !== parseInt(cachedUserId)) {
              cachedSellerId = oppositeUserId;
              console.log("[Offer] Seller ID trouv√© via cache inbox (opposite_user):", cachedSellerId);
              return cachedSellerId;
            }
          }
        }
      }
    }
    
    try {
      const response = await fetch('https://www.vinted.fr/api/v2/inbox?page=1&per_page=20', {
        credentials: 'include',
        headers: {
          'accept': 'application/json, text/plain, */*',
          'accept-language': 'fr',
        }
      });
  
      if (response.ok) {
        const data = await response.json();
        // Mettre en cache
        cachedInboxData = data;
        cachedInboxTime = Date.now();
        
        if (data.conversations && data.conversations.length > 0) {
          // Prendre le premier opposite_user qui n'est pas nous
          for (const conversation of data.conversations) {
            if (conversation.opposite_user && conversation.opposite_user.id) {
              const oppositeUserId = parseInt(conversation.opposite_user.id);
              if (cachedUserId && oppositeUserId !== parseInt(cachedUserId)) {
                cachedSellerId = oppositeUserId;
                return oppositeUserId;
              }
            }
          }
        }
      }
    } catch (error) {
      console.warn("[Offer] Erreur lors de la r√©cup√©ration du seller_id depuis les conversations:", error);
    }
  
    return null;
  }
  
  /**
   * R√©cup√®re les options d'offres depuis l'API Vinted
   * @param {Object} options - Options pour la requ√™te
   * @param {Object} options.price - Prix avec amount et currency_code
   * @param {number} options.seller_id - ID du vendeur
   * @returns {Promise<Object|null>} - Options d'offres ou null
   */
  async function fetchOfferOptions({ price, seller_id }) {
    try {
      // R√©cup√©rer le token CSRF (fonction disponible dans messages.js du m√™me bundle)
      let csrfToken = null;
      if (typeof getCsrfToken === 'function') {
        csrfToken = await getCsrfToken();
      }
      
      // Si pas de token, essayer de le r√©cup√©rer depuis la page
      if (!csrfToken && typeof tryGetCsrfTokenFromPage === 'function') {
        csrfToken = await tryGetCsrfTokenFromPage();
      }
      
      if (!csrfToken) {
        console.warn("[Offer] Token CSRF non trouv√©, la requ√™te peut √©chouer");
      }
      
      // R√©cup√©rer l'anon_id si disponible
      let anonId = null;
      if (typeof getAnonId === 'function') {
        anonId = getAnonId();
      }
      
      const headers = {
        'accept': 'application/json, text/plain, */*',
        'content-type': 'application/json',
      };
      
      // Ajouter le CSRF token si disponible
      if (csrfToken) {
        headers['x-csrf-token'] = csrfToken;
      }
      
      // Ajouter l'anon_id si disponible
      if (anonId) {
        headers['x-anon-id'] = anonId;
      }
      
      const response = await fetch('https://www.vinted.fr/api/v2/offers/request_options', {
        method: 'POST',
        credentials: 'include',
        headers: headers,
        body: JSON.stringify({
          price: price,
          seller_id: seller_id
        })
      });
  
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        console.error("[Offer] Erreur API:", errorData);
        throw new Error(`HTTP ${response.status}: ${errorData.message || 'Erreur inconnue'}`);
      }
  
      const data = await response.json();
      if (data.request_options) {
        return {
          remaining: data.request_options.remaining || data.request_options.remaining_offer_count || 0,
          max_offer_count: data.request_options.max_offer_count || 0
        };
      }
      return null;
    } catch (error) {
      console.error("[Offer] Erreur lors de la r√©cup√©ration des options d'offres:", error);
      return null;
    }
  }
  
  /**
   * Charge les options d'offres et retourne le nombre d'offres restantes
   * @returns {Promise<number|null>} - Nombre d'offres restantes ou null
   */
  async function loadRemainingOffers() {
    const sellerId = await getSellerIdForOfferOptions();
    if (!sellerId) {
      console.warn("[Offer] Impossible de r√©cup√©rer un seller_id pour les options d'offres");
      return null;
    }
  
    const offerOptions = await fetchOfferOptions({
      price: { amount: "30.0", currency_code: "EUR" },
      seller_id: sellerId
    });
  
    return offerOptions ? offerOptions.remaining : null;
  }
  
  /**
   * Affiche le nombre d'offres restantes √† gauche du wallet
   * @param {number|null} remainingOffers - Nombre d'offres restantes
   */
  function displayRemainingOffers(remainingOffers) {
    // Chercher ou cr√©er l'√©l√©ment d'affichage des offres
    let offersDisplay = document.getElementById('vinted-offers-count');
    const walletDisplay = document.getElementById('vinted-wallet-balance');
    
    if (!walletDisplay) return;
  
    if (!offersDisplay) {
      // Cr√©er l'√©l√©ment d'affichage des offres
      offersDisplay = document.createElement("div");
      offersDisplay.id = "vinted-offers-count";
      offersDisplay.className = "vinted-offers-count";
      // Les styles sont maintenant dans styles.css
      
      // Ins√©rer avant le wallet
      if (walletDisplay.parentNode) {
        walletDisplay.parentNode.insertBefore(offersDisplay, walletDisplay);
      }
    }
  
    if (remainingOffers !== null) {
      offersDisplay.textContent = `${remainingOffers} offres restantes`;
      offersDisplay.title = `Offres restantes: ${remainingOffers}`;
      offersDisplay.style.display = '';
    } else {
      // Afficher "Chargement..." si null pour donner un feedback imm√©diat
      offersDisplay.textContent = 'Chargement...';
      offersDisplay.title = 'Chargement des offres restantes';
      offersDisplay.style.display = '';
    }
  }
  
  /**
   * Initialise l'affichage du nombre d'offres restantes
   */
  async function initOfferCount() {
    // Afficher imm√©diatement l'√©l√©ment avec "Chargement..." pour un meilleur feedback
    displayRemainingOffers(null);
    
    // Charger les offres restantes en arri√®re-plan
    const remainingOffers = await loadRemainingOffers();
    displayRemainingOffers(remainingOffers);
    return remainingOffers;
  }
  
  

  // ==========================================
  // buyButton.js
  // ==========================================
  
  // ==================== BUY BUTTON TOGGLE ====================
  async function loadBuyButtonState() {
    try {
      const result = await chrome.storage.local.get(CONFIG.BUY_BUTTON_KEY);
      state.buyButtonEnabled = result[CONFIG.BUY_BUTTON_KEY] !== false;
      applyBuyButtonState();
    } catch (error) {
      console.error("[Buy Button] Erreur lors du chargement:", error);
    }
  }
  
  async function toggleBuyButton() {
    state.buyButtonEnabled = !state.buyButtonEnabled;
    await chrome.storage.local.set({ [CONFIG.BUY_BUTTON_KEY]: state.buyButtonEnabled });
    applyBuyButtonState();
    updateBuyButtonToggle();
  }
  
  function applyBuyButtonState() {
    if (state.buyButtonEnabled) {
      document.documentElement.classList.remove('vinted-buy-button-disabled');
    } else {
      document.documentElement.classList.add('vinted-buy-button-disabled');
    }
  }
  
  function updateBuyButtonToggle() {
    const btn = document.getElementById('buy-button-toggle');
    if (btn) {
      btn.innerHTML = state.buyButtonEnabled 
        ? '<svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>'
        : '<svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>';
      btn.title = state.buyButtonEnabled ? 'D√©sactiver le bouton Buy' : 'Activer le bouton Buy';
    }
  }

  // ==========================================
  // api.js
  // ==========================================
  
  // ==================== API ====================
  function extractVintedUrlParams() {
    const currentUrl = new URL(window.location.href);
    const params = {};
    
    const relevantParams = [
      'brand_ids[]',
      'size_ids[]',
      'color_ids[]',
      'material_ids[]',
      'status_ids[]',
      'catalog_ids[]',
      'price_from',
      'price_to',
      'currency',
      'order',
      'search_text'
    ];
    
    for (const [key, value] of currentUrl.searchParams.entries()) {
      if (key.endsWith('[]')) {
        if (!params[key]) {
          params[key] = [];
        }
        params[key].push(value);
      } else if (relevantParams.includes(key)) {
        params[key] = value;
      }
    }
    
    return params;
  }
  
  function extractItems(data) {
    if (data.items) return data.items;
    if (data.catalog_items) return data.catalog_items;
    if (data.catalog?.items) return data.catalog.items;
    if (data.data?.items) return data.data.items;
    return [];
  }
  
  async function fetchNewItems() {
    const url = new URL("https://www.vinted.fr/api/v2/catalog/items");
    const vintedParams = extractVintedUrlParams();
    
    if (!vintedParams['brand_ids[]'] || vintedParams['brand_ids[]'].length === 0) {
      url.searchParams.set("brand_ids[]", CONFIG.DEFAULT_BRAND_ID);
    } else {
      vintedParams['brand_ids[]'].forEach(brandId => {
        url.searchParams.append("brand_ids[]", brandId);
      });
    }
    
    for (const [key, value] of Object.entries(vintedParams)) {
      if (key === 'brand_ids[]') continue;
      if (Array.isArray(value)) {
        value.forEach(v => url.searchParams.append(key, v));
      } else {
        url.searchParams.set(key, value);
      }
    }
    
    if (!url.searchParams.has("order")) {
      url.searchParams.set("order", "newest_first");
    }
    url.searchParams.set("page", "1");
    const futureTime = Math.floor(Date.now() / 1000) + 30;
    url.searchParams.set("time", futureTime.toString());
  
    const response = await fetch(url.toString(), {
      credentials: "include",
      headers: {
        "accept": "application/json, text/plain, */*",
        "accept-language": "fr-FR,fr;q=0.9",
      },
    });
  
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
  
    const data = await response.json();
    return extractItems(data);
  }

  // ==========================================
  // itemManager.js
  // ==========================================
  
  // ==================== ITEM MANAGER ====================
  /**
   * Met √† jour l'ic√¥ne SVG de favori (rempli ou vide)
   */
  function updateFavoriteIcon(iconElement, isFavorited) {
    if (!iconElement) return;
    
    const heartFilled = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>`;
    const heartOutline = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" fill="none"></path>`;
    
    if (isFavorited) {
      iconElement.innerHTML = heartFilled;
      iconElement.style.fill = 'currentColor';
    } else {
      iconElement.innerHTML = heartOutline;
      iconElement.style.fill = 'none';
    }
  }
  
  /**
   * Cr√©e une ic√¥ne SVG de chargement
   */
  function createLoadingIcon() {
    return `<svg class="favorite-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
    </svg>`;
  }
  
  function registerItems(incomingItems) {
    const newItems = incomingItems.filter((item) => !state.seenIds.has(item.id));
    if (newItems.length === 0) return newItems;
    
    state.items = [...newItems, ...state.items].slice(0, CONFIG.MAX_ITEMS);
    newItems.forEach((item) => state.seenIds.add(item.id));
    
    // Limiter la taille de seenIds pour √©viter les fuites m√©moire
    // Garder seulement les IDs des items actuellement dans state.items
    if (state.seenIds.size > CONFIG.MAX_ITEMS * 2) {
      const currentIds = new Set(state.items.map(item => item.id));
      state.seenIds = new Set([...currentIds, ...Array.from(state.seenIds).slice(0, CONFIG.MAX_ITEMS)]);
    }
    
    return newItems;
  }
  
  function createItemCard(item) {
    const photo = item.photos?.[0]?.url || item.photo?.url || "";
    const price = formatPrice(item);
    const size = extractSize(item);
    const condition = extractCondition(item);
    const permalink = item.url?.startsWith("http") ? item.url : `https://www.vinted.fr${item.url}`;
    
    // V√©rifier les alertes
    const matchingAlerts = checkItemAgainstAlerts(item);
    const hasAlert = matchingAlerts.length > 0;
    const alertClass = hasAlert ? ' alert-match' : '';
    const alertDataAttr = hasAlert ? ` data-alert-id="${matchingAlerts[0].id}"` : '';
    const alertColor = hasAlert ? matchingAlerts[0].color : '';
    const alertStyle = hasAlert ? ` style="--alert-color: ${alertColor};"` : '';
  
    return `
      <div class="item-card${alertClass}"${alertDataAttr}${alertStyle} data-item-url="${permalink}">
        ${hasAlert ? '<div class="alert-indicator" style="background: var(--alert-color, #10b981);"></div>' : ''}
        <a href="${permalink}" class="item-link" data-item-id="${item.id}">
          ${photo ? `<img src="${photo}" alt="${item.title}" class="item-image" />` : '<div class="item-no-image">Pas d\'image</div>'}
          <div class="item-header">
            <h3 class="item-title">${escapeHtml(item.title)}</h3>
          </div>
          <div class="item-footer">
            <div class="item-badges">
              ${size ? `<span class="badge">${size}</span>` : ""}
              ${condition ? `<span class="badge">${condition}</span>` : ""}
            </div>
            <span class="item-price">${price}</span>
          </div>
        </a>
        <button class="btn-favorite-item" data-item-id="${item.id}" data-item-url="${permalink}" title="Ajouter aux favoris">
          <svg class="favorite-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
          </svg>
        </button>
        <button class="btn-buy-item" data-item-url="${permalink}" title="Acheter rapidement">
          <svg class="buy-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"></path>
          </svg>
          <span class="buy-text">Buy</span>
        </button>
      </div>
    `;
  }
  
  function renderItems() {
    const container = document.getElementById("items-container");
    if (!container) return;
    container.innerHTML = state.items.map((item) => createItemCard(item)).join("");
    
    // Attacher les event listeners aux boutons Buy
    attachBuyButtonListeners();
    
    // Attacher les event listeners aux boutons Favoris
    attachFavoriteButtonListeners();
    
    // Attacher les event listeners aux liens des articles pour ouvrir la modal
    attachItemLinkListeners();
    
    // R√©appliquer le filtre par alertes si actif
    if (isAlertFilterActive) {
      applyAlertFilter();
    }
  }
  
  /**
   * Extrait l'ID et le slug d'un item depuis son URL
   * @param {string} url - URL de l'item
   * @returns {Object|null} - {id, slug} ou null
   */
  function extractItemInfoFromUrl(url) {
    if (!url) return null;
    
    // Pattern: /items/123456-slug-ou-nom
    const match = url.match(/\/items\/(\d+)(?:-([^/?]+))?/);
    if (match) {
      return {
        id: match[1],
        slug: match[2] || ''
      };
    }
    
    return null;
  }
  
  /**
   * Attache les event listeners aux liens des articles pour ouvrir la modal au lieu de rediriger
   */
  function attachItemLinkListeners() {
    const itemLinks = document.querySelectorAll('.item-link');
    itemLinks.forEach(link => {
      // Retirer les anciens listeners pour √©viter les duplications
      const newLink = link.cloneNode(true);
      link.parentNode.replaceChild(newLink, link);
      
      newLink.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        const url = newLink.href || newLink.getAttribute('href');
        if (!url) return;
        
        const itemInfo = extractItemInfoFromUrl(url);
        if (!itemInfo || !itemInfo.id) {
          // Si on ne peut pas extraire l'info, ouvrir le lien normalement
          window.open(url, '_blank');
          return;
        }
        
        console.log('[Vinted Item Details] üñ±Ô∏è Clic sur article depuis la sidebar:', itemInfo);
        
        // V√©rifier si showItemDetails est disponible (depuis messages-notifier-bundled.js)
        if (typeof showItemDetails === 'function') {
          await showItemDetails(itemInfo.id, itemInfo.slug);
        } else {
          // Fallback: ouvrir le lien si la fonction n'est pas disponible
          console.warn('[Vinted Item Details] showItemDetails non disponible, ouverture du lien');
          window.open(url, '_blank');
        }
      });
    });
  }
  
  function attachBuyButtonListeners() {
    const buyButtons = document.querySelectorAll('.btn-buy-item');
    buyButtons.forEach(btn => {
      // Retirer les anciens listeners pour √©viter les duplications
      const newBtn = btn.cloneNode(true);
      btn.parentNode.replaceChild(newBtn, btn);
      
      newBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const itemUrl = newBtn.dataset.itemUrl;
        if (itemUrl) {
          quickBuyItem(itemUrl);
        }
      });
    });
  }
  
  async function attachFavoriteButtonListeners() {
    const favoriteButtons = document.querySelectorAll('.btn-favorite-item');
    favoriteButtons.forEach(btn => {
      // Retirer les anciens listeners pour √©viter les duplications
      const newBtn = btn.cloneNode(true);
      btn.parentNode.replaceChild(newBtn, btn);
      
      // V√©rifier l'√©tat initial (est-ce que l'item est d√©j√† en favoris)
      const itemId = newBtn.dataset.itemId;
      if (itemId && typeof window.isItemPinned === 'function') {
        window.isItemPinned(itemId).then(isPinned => {
          if (isPinned) {
            newBtn.classList.add('favorited');
            newBtn.title = 'Retirer des favoris';
          }
        });
      }
      
      newBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        const itemId = newBtn.dataset.itemId;
        const itemUrl = newBtn.dataset.itemUrl;
        
        if (!itemId || !itemUrl) return;
        
        // Extraire le path depuis l'URL
        let itemPath = '';
        try {
          const url = new URL(itemUrl);
          itemPath = url.pathname;
        } catch (e) {
          // Si l'URL est invalide, utiliser le format par d√©faut
        }
        
        // Afficher le chargement
        const favoriteIcon = newBtn.querySelector('.favorite-icon');
        const originalIconHTML = favoriteIcon ? favoriteIcon.outerHTML : '';
        if (favoriteIcon) {
          favoriteIcon.outerHTML = createLoadingIcon();
        }
        newBtn.disabled = true;
        newBtn.style.opacity = '0.7';
        
        try {
          // V√©rifier l'√©tat actuel avant l'action
          const wasPinned = newBtn.classList.contains('favorited');
          
          // Utiliser la fonction addToFavourites depuis itemDetails.js si disponible
          if (typeof window.addToFavourites === 'function') {
            await window.addToFavourites(itemId, itemPath);
          } else if (typeof window.togglePinItem === 'function') {
            // Fallback: utiliser togglePinItem si disponible
            const itemInfo = extractItemInfoFromUrl(itemUrl);
            if (itemInfo) {
              await window.togglePinItem({ id: itemId, url: itemUrl });
            }
          } else {
            console.warn('[Vinted Favourites] Fonction addToFavourites non disponible');
          }
          
          // Mettre √† jour imm√©diatement l'√©tat visuel (toggle)
          const isNowPinned = !wasPinned;
          const newBtnIcon = newBtn.querySelector('.favorite-icon');
          if (isNowPinned) {
            newBtn.classList.add('favorited');
            newBtn.title = 'Retirer des favoris';
            updateFavoriteIcon(newBtnIcon, true);
          } else {
            newBtn.classList.remove('favorited');
            newBtn.title = 'Ajouter aux favoris';
            updateFavoriteIcon(newBtnIcon, false);
          }
          
          // Mettre √† jour tous les autres boutons favoris pour le m√™me item sur la page
          const allFavoriteButtons = document.querySelectorAll(`.btn-favorite-item[data-item-id="${itemId}"]`);
          allFavoriteButtons.forEach(btn => {
            if (btn !== newBtn) {
              const icon = btn.querySelector('.favorite-icon');
              if (isNowPinned) {
                btn.classList.add('favorited');
                btn.title = 'Retirer des favoris';
                updateFavoriteIcon(icon, true);
              } else {
                btn.classList.remove('favorited');
                btn.title = 'Ajouter aux favoris';
                updateFavoriteIcon(icon, false);
              }
            }
          });
          
          // Attendre un peu pour que l'API se synchronise, puis v√©rifier l'√©tat r√©el
          await new Promise(resolve => setTimeout(resolve, 300));
          
          // Utiliser la fonction globale pour mettre √† jour tous les boutons
          if (typeof window.updateFavoriteButtonsOnPage === 'function') {
            await window.updateFavoriteButtonsOnPage(itemId);
          } else if (typeof window.isItemPinned === 'function') {
            // Fallback: v√©rifier manuellement
            const actualIsPinned = await window.isItemPinned(itemId);
            allFavoriteButtons.forEach(btn => {
              const icon = btn.querySelector('.favorite-icon');
              if (actualIsPinned) {
                btn.classList.add('favorited');
                btn.title = 'Retirer des favoris';
                updateFavoriteIcon(icon, true);
              } else {
                btn.classList.remove('favorited');
                btn.title = 'Ajouter aux favoris';
                updateFavoriteIcon(icon, false);
              }
            });
          }
        } catch (error) {
          console.error('[Vinted Favourites] Erreur lors de l\'ajout aux favoris:', error);
          const favoriteIcon = newBtn.querySelector('.favorite-icon');
          if (favoriteIcon && originalIconHTML) {
            favoriteIcon.outerHTML = originalIconHTML;
          }
        } finally {
          newBtn.disabled = false;
          newBtn.style.opacity = '1';
        }
      });
    });
  }
  
  function quickBuyItem(itemUrl) {
    // Ajouter le param√®tre auto_buy=true √† l'URL pour d√©clencher le script auto-buy
    const url = new URL(itemUrl);
    url.searchParams.set('auto_buy', 'true');
    
    // Ouvrir l'article dans un nouvel onglet
    const newTab = window.open(url.toString(), '_blank');
    
    if (newTab) {
      console.log('Ouverture de l\'article pour achat rapide:', url.toString());
    } else {
      console.error('Impossible d\'ouvrir l\'onglet. Popup bloqu√©e ?');
    }
  }
  
  function prependNewItems(newItems) {
    const container = document.getElementById("items-container");
    if (!container || newItems.length === 0) return;
    
    // Attacher les event listeners aux nouveaux liens d'articles
    setTimeout(() => {
      attachItemLinkListeners();
    }, 100);
  
    const oldNewItems = container.querySelectorAll(".new-item");
    oldNewItems.forEach((el) => el.classList.remove("new-item"));
  
    const fragment = document.createDocumentFragment();
    const tempDiv = document.createElement("div");
  
    newItems.forEach((item) => {
      tempDiv.innerHTML = createItemCard(item);
      const cardElement = tempDiv.firstElementChild;
      if (cardElement) {
        cardElement.classList.add("new-item");
        fragment.appendChild(cardElement);
      }
    });
  
    if (container.firstChild) {
      container.insertBefore(fragment, container.firstChild);
    } else {
      container.appendChild(fragment);
    }
  
    while (container.children.length > CONFIG.MAX_ITEMS) {
      container.removeChild(container.lastChild);
    }
    
    // Attacher les event listeners aux nouveaux boutons Buy
    attachBuyButtonListeners();
    attachFavoriteButtonListeners();
    
    // R√©appliquer le filtre par alertes si actif
    if (isAlertFilterActive) {
      applyAlertFilter();
    }
  }

  // ==========================================
  // monitor.js
  // ==========================================
  
  // ==================== MONITOR ====================
  let isPollingItems = false;
  
  function startMonitor() {
    if (state.isPolling) return;
  
    state.isPolling = true;
    const btn = document.getElementById("toggle-monitor");
    if (btn) {
      btn.textContent = "‚è∏";
      btn.style.background = "#dc2626";
    }
  
    pollItems();
    
    // S'assurer qu'on ne cr√©e pas plusieurs intervalles
    if (state.pollInterval) {
      clearInterval(state.pollInterval);
      state.pollInterval = null;
    }
    
    // Obtenir l'intervalle depuis les settings ou la config
    const getItemsInterval = async () => {
      if (typeof getInterval === 'function') {
        return await getInterval('items');
      }
      return CONFIG.POLL_INTERVAL || 3000;
    };
    
    getItemsInterval().then(interval => {
      // Double v√©rification
      if (state.pollInterval) {
        clearInterval(state.pollInterval);
      }
      
      state.pollInterval = setInterval(() => {
        // √âviter les appels multiples si une requ√™te est d√©j√† en cours
        if (isPollingItems) {
          console.log("[Vinted Monitor] Requ√™te en cours, skip du polling");
          return;
        }
        pollItems();
      }, interval);
      
      console.log(`[Vinted Monitor] ‚úÖ Polling activ√© (toutes les ${interval / 1000} secondes)`);
    });
  }
  
  function stopMonitor() {
    state.isPolling = false;
    const btn = document.getElementById("toggle-monitor");
    if (btn) {
      btn.textContent = "‚ñ∂";
      btn.style.background = "#3b82f6";
    }
  
    if (state.pollInterval) {
      clearInterval(state.pollInterval);
      state.pollInterval = null;
    }
  }
  
  function toggleMonitor() {
    if (state.isPolling) {
      stopMonitor();
    } else {
      startMonitor();
    }
  }
  
  async function pollItems() {
    // √âviter les appels multiples simultan√©s
    if (isPollingItems) {
      console.log("[Vinted Monitor] Polling d√©j√† en cours, skip");
      return;
    }
    
    isPollingItems = true;
    const isFirstFetch = state.items.length === 0;
  
    try {
      const incomingItems = await fetchNewItems();
  
      if (incomingItems && incomingItems.length > 0) {
        const newItems = registerItems(incomingItems);
  
        if (isFirstFetch) {
          renderItems();
          console.log(`[Vinted Monitor] ${state.items.length} articles charg√©s`);
        } else if (newItems.length > 0) {
          prependNewItems(newItems);
          console.log(`[Vinted Monitor] ${newItems.length} nouveau${newItems.length > 1 ? "x" : ""} article${newItems.length > 1 ? "s" : ""}`);
        }
      } else {
        console.log("[Vinted Monitor] Aucun article trouv√©");
      }
    } catch (error) {
      console.error("[Vinted Monitor] Erreur:", error);
    } finally {
      isPollingItems = false;
    }
  }
  
  let lastUrl = window.location.href;
  function observeUrlChanges() {
    const observer = new MutationObserver(() => {
      if (lastUrl !== window.location.href) {
        console.log("[Vinted Monitor] URL chang√©e, r√©initialisation...");
        lastUrl = window.location.href;
        state.seenIds.clear();
        state.items = [];
        // R√©appliquer le mode nuit apr√®s changement d'URL
        ensureDarkModeApplied();
        if (state.isPolling) {
          stopMonitor();
          setTimeout(() => startMonitor(), 500);
        }
      }
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    
    // Intercepter les navigations via pushState/replaceState
    const originalPushState = history.pushState;
    const originalReplaceState = history.replaceState;
    
    history.pushState = function(...args) {
      originalPushState.apply(history, args);
      setTimeout(() => ensureDarkModeApplied(), 100);
    };
    
    history.replaceState = function(...args) {
      originalReplaceState.apply(history, args);
      setTimeout(() => ensureDarkModeApplied(), 100);
    };
    
    // Intercepter les √©v√©nements popstate (retour/avance dans l'historique)
    window.addEventListener('popstate', () => {
      setTimeout(() => ensureDarkModeApplied(), 100);
    });
  }

  // ==========================================
  // filterManager.js
  // ==========================================
  
  // ==================== FILTER MANAGER ====================
  async function loadSavedFilters() {
    try {
      const result = await chrome.storage.local.get(CONFIG.STORAGE_KEY);
      state.savedFilters = result[CONFIG.STORAGE_KEY] || [];
      console.log("[Filter Manager] Filtres charg√©s:", state.savedFilters);
    } catch (error) {
      console.error("[Filter Manager] Erreur lors du chargement:", error);
      state.savedFilters = [];
    }
  }
  
  async function saveFiltersToStorage() {
    try {
      await chrome.storage.local.set({ [CONFIG.STORAGE_KEY]: state.savedFilters });
      console.log("[Filter Manager] Filtres sauvegard√©s:", state.savedFilters);
    } catch (error) {
      console.error("[Filter Manager] Erreur lors de la sauvegarde:", error);
    }
  }
  
  function getCurrentFilters() {
    const url = new URL(window.location.href);
    const filters = {};
    
    for (const [key, value] of url.searchParams.entries()) {
      if (key.endsWith('[]')) {
        if (!filters[key]) filters[key] = [];
        filters[key].push(value);
      } else if (['price_from', 'price_to', 'order'].includes(key)) {
        filters[key] = value;
      }
    }
    
    return filters;
  }
  
  function applyFilter(filter) {
    const url = new URL(window.location.href);
    const catalogPath = url.pathname;
    url.search = '';
    url.pathname = catalogPath;
    
    for (const [key, value] of Object.entries(filter.params)) {
      if (Array.isArray(value)) {
        value.forEach(v => url.searchParams.append(key, v));
      } else {
        url.searchParams.set(key, value);
      }
    }
    
    if (!url.searchParams.has('order')) {
      url.searchParams.set('order', 'newest_first');
    }
    
    // D√©coder l'URL pour avoir [] au lieu de %5B%5D
    const cleanUrl = decodeURIComponent(url.toString());
    window.location.href = cleanUrl;
  }
  
  async function saveCurrentFilter() {
    const name = prompt("Nom du filtre:");
    if (!name) return;
    
    const filters = getCurrentFilters();
    const newFilter = {
      id: Date.now().toString(),
      name: name,
      params: filters,
      createdAt: new Date().toISOString()
    };
    
    state.savedFilters.push(newFilter);
    await saveFiltersToStorage();
    renderFilterList();
  }
  
  async function deleteFilter(filterId) {
    if (!confirm("Supprimer ce filtre ?")) return;
    
    state.savedFilters = state.savedFilters.filter(f => f.id !== filterId);
    await saveFiltersToStorage();
    renderFilterList();
  }
  
  function isFilterActive(filter) {
    const currentFilters = getCurrentFilters();
    
    // Comparer les param√®tres
    const filterKeys = Object.keys(filter.params).sort();
    const currentKeys = Object.keys(currentFilters).sort();
    
    if (filterKeys.length !== currentKeys.length) return false;
    if (filterKeys.join(',') !== currentKeys.join(',')) return false;
    
    // Comparer les valeurs
    for (const key of filterKeys) {
      const filterValue = filter.params[key];
      const currentValue = currentFilters[key];
      
      if (Array.isArray(filterValue)) {
        if (!Array.isArray(currentValue)) return false;
        if (filterValue.length !== currentValue.length) return false;
        
        const sortedFilter = [...filterValue].sort();
        const sortedCurrent = [...currentValue].sort();
        if (sortedFilter.join(',') !== sortedCurrent.join(',')) return false;
      } else {
        if (filterValue !== currentValue) return false;
      }
    }
    
    return true;
  }
  
  function renderFilterList() {
    const filterList = document.getElementById('filter-list');
    if (!filterList) return;
    
    // Mettre √† jour le compteur
    updateFiltersCount();
    
    if (state.savedFilters.length === 0) {
      filterList.innerHTML = '<p class="filter-empty">Aucun filtre sauvegard√©</p>';
      return;
    }
    
    filterList.innerHTML = state.savedFilters.map(filter => {
      const paramCount = Object.keys(filter.params).reduce((acc, key) => {
        return acc + (Array.isArray(filter.params[key]) ? filter.params[key].length : 1);
      }, 0);
      
      const isActive = isFilterActive(filter);
      const activeClass = isActive ? ' filter-item-active' : '';
      
      // Afficher le search_text s'il existe
      const searchText = filter.params.search_text ? `üîç "${decodeURIComponent(filter.params.search_text)}"` : '';
      
      return `
        <div class="filter-item${activeClass}" data-filter-id="${filter.id}">
          <div class="filter-item-content" data-filter-id="${filter.id}">
            <span class="filter-item-name">${escapeHtml(filter.name)}</span>
            ${searchText ? `<span class="filter-item-search">${escapeHtml(searchText)}</span>` : ''}
            <span class="filter-item-count">${paramCount} filtre${paramCount > 1 ? 's' : ''}</span>
            ${isActive ? '<span class="filter-active-badge"></span>' : ''}
          </div>
          <button class="btn-delete-filter" data-filter-id="${filter.id}" title="Supprimer ce filtre">üóëÔ∏è</button>
        </div>
      `;
    }).join('');
    
    // Rendre tout le filtre cliquable (sauf si actif)
    filterList.querySelectorAll('.filter-item:not(.filter-item-active)').forEach(item => {
      item.addEventListener('click', (e) => {
        // Ne pas d√©clencher si on clique sur le bouton supprimer
        if (e.target.closest('.btn-delete-filter')) return;
        
        const filterId = item.dataset.filterId;
        const filter = state.savedFilters.find(f => f.id === filterId);
        if (filter) applyFilter(filter);
      });
      
      // Ajouter un style pointer sur hover
      item.style.cursor = 'pointer';
    });
    
    filterList.querySelectorAll('.btn-delete-filter').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation(); // Emp√™cher la propagation au parent
        const filterId = e.target.dataset.filterId;
        deleteFilter(filterId);
      });
    });
  }
  
  let filterManagerRetries = 0;
  const MAX_FILTER_RETRIES = 10;
  
  function createFilterManager() {
    const sidebar = document.getElementById('sidebar');
    
    if (!sidebar) {
      filterManagerRetries++;
      if (filterManagerRetries < MAX_FILTER_RETRIES) {
        console.warn(`[Filter Manager] Sidebar non trouv√©e (tentative ${filterManagerRetries}/${MAX_FILTER_RETRIES}), r√©essai dans 500ms`);
        setTimeout(createFilterManager, 500);
      } else {
        console.error("[Filter Manager] Sidebar introuvable apr√®s plusieurs tentatives, abandon");
      }
      return;
    }
    
    if (document.getElementById('filter-manager')) {
      console.log("[Filter Manager] Interface d√©j√† cr√©√©e");
      return;
    }
    
    try {
      // Cr√©er le conteneur sticky qui englobera filtres + alertes
      const stickyContainer = document.createElement('div');
      stickyContainer.id = 'sidebar-sticky-container';
      stickyContainer.className = 'sidebar-sticky-container';
      
      const filterManager = document.createElement('div');
      filterManager.id = 'filter-manager';
      filterManager.className = 'filter-manager';
      filterManager.style.display = 'none'; // Masqu√© par d√©faut
      filterManager.innerHTML = `
        <div class="filter-manager-header">
          <h3 class="filter-manager-title">Filtres Sauvegard√©s</h3>
          <button id="save-current-filter" class="btn-save-filter" title="Sauvegarder le filtre actuel">Sauvegarder</button>
        </div>
        <div id="filter-list" class="filter-list">
          <p class="filter-empty">Aucun filtre sauvegard√©</p>
        </div>
      `;
      
      stickyContainer.appendChild(filterManager);
      sidebar.insertBefore(stickyContainer, sidebar.firstChild);
      document.getElementById('save-current-filter').addEventListener('click', saveCurrentFilter);
      loadSavedFilters().then(() => renderFilterList());
      
      console.log("[Filter Manager] Interface cr√©√©e avec succ√®s");
      filterManagerRetries = 0;
    } catch (error) {
      console.error("[Filter Manager] Erreur lors de la cr√©ation:", error);
      filterManagerRetries++;
      if (filterManagerRetries < MAX_FILTER_RETRIES) {
        setTimeout(createFilterManager, 500);
      }
    }
  }

  // ==========================================
  // alertSystem.js
  // ==========================================
  
  // ==================== ALERT SYSTEM ====================
  
  // Couleurs pr√©d√©finies pour les alertes
  const ALERT_COLORS = [
    { name: 'Vert', value: '#10b981' },
    { name: 'Vert clair', value: '#34d399' },
    { name: 'Emeraude', value: '#059669' },
    { name: 'Lime', value: '#84cc16' },
    { name: 'Vert fonc√©', value: '#047857' },
    { name: 'Menthe', value: '#6ee7b7' },
    { name: 'Bleu', value: '#3b82f6' },
    { name: 'Bleu clair', value: '#60a5fa' },
    { name: 'Cyan', value: '#06b6d4' },
    { name: 'Indigo', value: '#6366f1' },
    { name: 'Bleu fonc√©', value: '#1e40af' },
    { name: 'Sky', value: '#0ea5e9' },
    { name: 'Rouge', value: '#ef4444' },
    { name: 'Rouge clair', value: '#f87171' },
    { name: 'Rose', value: '#ec4899' },
    { name: 'Rose clair', value: '#f472b6' },
    { name: 'Rouge fonc√©', value: '#b91c1c' },
    { name: 'Fuchsia', value: '#d946ef' },
    { name: 'Orange', value: '#f97316' },
    { name: 'Orange clair', value: '#fb923c' },
    { name: 'Amber', value: '#f59e0b' },
    { name: 'Jaune', value: '#eab308' },
    { name: 'Orange fonc√©', value: '#c2410c' },
    { name: 'P√™che', value: '#fdba74' },
    { name: 'Violet', value: '#a855f7' },
    { name: 'Violet clair', value: '#c084fc' },
    { name: 'Pourpre', value: '#9333ea' },
    { name: 'Mauve', value: '#e879f9' },
    { name: 'Violet fonc√©', value: '#7c3aed' },
    { name: 'Lavande', value: '#c4b5fd' },
  ];
  
  // Cr√©er un s√©lecteur de couleur modal
  function showColorPicker(currentColor = '#10b981') {
    return new Promise((resolve) => {
      // Cr√©er le modal
      const modal = document.createElement('div');
      modal.className = 'color-picker-modal';
      modal.innerHTML = `
        <div class="color-picker-overlay"></div>
        <div class="color-picker-content">
          <h3 class="color-picker-title">Choisir une couleur</h3>
          <div class="color-picker-grid">
            ${ALERT_COLORS.map(color => `
              <button class="color-picker-option ${color.value === currentColor ? 'selected' : ''}" 
                      data-color="${color.value}"
                      style="background: ${color.value};"
                      title="${color.name}">
                ${color.value === currentColor ? '‚úì' : ''}
              </button>
            `).join('')}
          </div>
          <div class="color-picker-actions">
            <button class="btn-color-cancel">Annuler</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Event listeners
      const overlay = modal.querySelector('.color-picker-overlay');
      const cancelBtn = modal.querySelector('.btn-color-cancel');
      const colorOptions = modal.querySelectorAll('.color-picker-option');
      
      // Fermer sur overlay
      overlay.addEventListener('click', () => {
        modal.remove();
        resolve(null);
      });
      
      // Fermer sur annuler
      cancelBtn.addEventListener('click', () => {
        modal.remove();
        resolve(null);
      });
      
      // S√©lectionner une couleur
      colorOptions.forEach(option => {
        option.addEventListener('click', () => {
          const color = option.dataset.color;
          modal.remove();
          resolve(color);
        });
      });
    });
  }
  
  // Charger les alertes depuis le storage
  async function loadAlerts() {
    try {
      const result = await chrome.storage.local.get(CONFIG.ALERTS_STORAGE_KEY);
      state.alerts = result[CONFIG.ALERTS_STORAGE_KEY] || [];
      console.log("[Alert System] Alertes charg√©es:", state.alerts);
    } catch (error) {
      console.error("[Alert System] Erreur lors du chargement:", error);
      state.alerts = [];
    }
  }
  
  // Sauvegarder les alertes
  async function saveAlerts() {
    try {
      await chrome.storage.local.set({ [CONFIG.ALERTS_STORAGE_KEY]: state.alerts });
      console.log("[Alert System] Alertes sauvegard√©es:", state.alerts);
    } catch (error) {
      console.error("[Alert System] Erreur lors de la sauvegarde:", error);
    }
  }
  
  // V√©rifier si un item correspond √† une alerte
  function checkItemAgainstAlerts(item) {
    const matchingAlerts = [];
    const itemTitle = item.title.toLowerCase();
    const itemPrice = item.price?.amount || 0;
    
    for (const alert of state.alerts) {
      if (!alert.enabled) continue;
      
      const keywordsMatch = alert.keywords.length === 0 || 
        alert.keywords.some(keyword => itemTitle.includes(keyword.toLowerCase()));
      
      const priceMatch = !alert.maxPrice || itemPrice <= alert.maxPrice;
      
      if (keywordsMatch && priceMatch) {
        matchingAlerts.push(alert);
      }
    }
    
    return matchingAlerts;
  }
  
  // Cr√©er une nouvelle alerte
  async function createAlert() {
    const name = prompt("Nom de l'alerte:");
    if (!name) return;
    
    const keywordsInput = prompt("Mots-cl√©s (s√©par√©s par des virgules):");
    const keywords = keywordsInput ? keywordsInput.split(',').map(k => k.trim()).filter(k => k) : [];
    
    const maxPriceInput = prompt("Prix maximum (laisser vide pour ignorer):");
    const maxPrice = maxPriceInput ? parseFloat(maxPriceInput) : null;
    
    const color = await showColorPicker('#10b981');
    if (!color) return; // Annul√©
    
    const newAlert = {
      id: Date.now().toString(),
      name: name,
      keywords: keywords,
      maxPrice: maxPrice,
      enabled: true,
      color: color,
      createdAt: new Date().toISOString()
    };
    
    state.alerts.push(newAlert);
    await saveAlerts();
    renderAlertList();
  }
  
  // Supprimer une alerte
  async function deleteAlert(alertId) {
    if (!confirm("Supprimer cette alerte ?")) return;
    
    state.alerts = state.alerts.filter(a => a.id !== alertId);
    await saveAlerts();
    renderAlertList();
    
    // Retirer les highlights des items
    document.querySelectorAll(`.item-card[data-alert-id="${alertId}"]`).forEach(card => {
      card.classList.remove('alert-match');
      card.removeAttribute('data-alert-id');
      card.style.border = '';
    });
  }
  
  // Toggle enable/disable alerte
  async function toggleAlert(alertId) {
    const alert = state.alerts.find(a => a.id === alertId);
    if (alert) {
      alert.enabled = !alert.enabled;
      await saveAlerts();
      renderAlertList();
      
      // Mettre √† jour les items existants
      if (!alert.enabled) {
        // Si d√©sactiv√©e, retirer les bordures des items qui matchent cette alerte
        document.querySelectorAll(`.item-card[data-alert-id="${alertId}"]`).forEach(card => {
          card.classList.remove('alert-match');
          card.removeAttribute('data-alert-id');
          card.removeAttribute('style');
          // Retirer le voyant
          const indicator = card.querySelector('.alert-indicator');
          if (indicator) indicator.remove();
        });
      } else {
        // Si r√©activ√©e, re-v√©rifier tous les items
        reapplyAllAlerts();
      }
    }
  }
  
  // Re-appliquer toutes les alertes sur les items existants
  function reapplyAllAlerts() {
    const itemCards = document.querySelectorAll('.item-card');
    itemCards.forEach(card => {
      // Retirer les anciennes classes/attributs d'alerte
      card.classList.remove('alert-match');
      card.removeAttribute('data-alert-id');
      card.removeAttribute('style');
      
      // Retirer l'ancien indicateur
      const oldIndicator = card.querySelector('.alert-indicator');
      if (oldIndicator) oldIndicator.remove();
      
      // R√©cup√©rer le titre de l'item depuis la carte
      const titleElement = card.querySelector('.item-title');
      const priceElement = card.querySelector('.item-price');
      
      if (titleElement && priceElement) {
        const title = titleElement.textContent;
        const priceText = priceElement.textContent.replace('‚Ç¨', '').trim();
        const price = parseFloat(priceText) || 0;
        
        const item = {
          title: title,
          price: { amount: price }
        };
        
        // V√©rifier si l'item matche une alerte
        const matchingAlerts = checkItemAgainstAlerts(item);
        if (matchingAlerts.length > 0) {
          const alert = matchingAlerts[0];
          card.classList.add('alert-match');
          card.setAttribute('data-alert-id', alert.id);
          card.style.setProperty('--alert-color', alert.color);
          
          // Ajouter le voyant d'alerte
          const indicator = document.createElement('div');
          indicator.className = 'alert-indicator';
          indicator.style.background = alert.color;
          card.insertBefore(indicator, card.firstChild);
        }
      }
    });
  }
  
  // Editer une alerte
  async function editAlert(alertId) {
    const alert = state.alerts.find(a => a.id === alertId);
    if (!alert) return;
    
    const name = prompt("Nom de l'alerte:", alert.name);
    if (name === null) return;
    
    const keywordsInput = prompt("Mots-cl√©s (s√©par√©s par des virgules):", alert.keywords.join(', '));
    if (keywordsInput === null) return;
    
    const keywords = keywordsInput.split(',').map(k => k.trim()).filter(k => k);
    
    const maxPriceInput = prompt("Prix maximum (laisser vide pour ignorer):", alert.maxPrice || '');
    if (maxPriceInput === null) return;
    
    const maxPrice = maxPriceInput ? parseFloat(maxPriceInput) : null;
    
    const color = await showColorPicker(alert.color || '#10b981');
    if (!color) return; // Annul√©
    
    alert.name = name;
    alert.keywords = keywords;
    alert.maxPrice = maxPrice;
    alert.color = color;
    
    await saveAlerts();
    renderAlertList();
    
    // Re-appliquer les couleurs aux items existants
    reapplyAlertColors();
  }
  
  // Re-appliquer les couleurs des alertes aux items existants
  function reapplyAlertColors() {
    const itemCards = document.querySelectorAll('.item-card');
    itemCards.forEach(card => {
      const alertId = card.dataset.alertId;
      if (alertId) {
        const alert = state.alerts.find(a => a.id === alertId);
        if (alert && alert.color) {
          card.style.setProperty('--alert-color', alert.color);
        }
      }
    });
  }
  
  // Afficher la liste des alertes
  function renderAlertList() {
    const alertList = document.getElementById('alert-list');
    if (!alertList) return;
    
    // Mettre √† jour le compteur
    updateAlertsCount();
    
    if (state.alerts.length === 0) {
      alertList.innerHTML = '<p class="alert-empty">Aucune alerte cr√©√©e</p>';
      return;
    }
    
    alertList.innerHTML = state.alerts.map(alert => {
      const keywordsText = alert.keywords.length > 0 ? alert.keywords.join(', ') : 'Tous';
      const priceText = alert.maxPrice ? `‚â§ ${alert.maxPrice}‚Ç¨` : 'Aucune limite';
      const enabledClass = alert.enabled ? '' : ' alert-disabled';
      const alertColor = alert.color || '#10b981';
      
        return `
        <div class="alert-item${enabledClass}" data-alert-id="${alert.id}" style="border-left: 4px solid ${alertColor};">
          <div class="alert-item-content" data-alert-id="${alert.id}">
            <div class="alert-item-name">${escapeHtml(alert.name)}</div>
            <div class="alert-item-info">
              <span class="alert-info-item">
                <span class="alert-color-preview" style="background: ${alertColor};"></span>
              </span>
              <span class="alert-info-item">${escapeHtml(keywordsText)}</span>
              <span class="alert-info-separator">‚Ä¢</span>
              <span class="alert-info-item">${priceText}</span>
            </div>
          </div>
          <div class="alert-item-actions">
            <label class="alert-toggle">
              <input type="checkbox" ${alert.enabled ? 'checked' : ''} data-alert-id="${alert.id}" class="alert-toggle-input">
              <span class="alert-toggle-slider"></span>
            </label>
            <button class="btn-delete-alert" data-alert-id="${alert.id}" title="Supprimer">‚úñ</button>
          </div>
        </div>
      `;
    }).join('');
    
    // Event listeners
    alertList.querySelectorAll('.alert-toggle-input').forEach(toggle => {
      toggle.addEventListener('change', (e) => {
        e.stopPropagation();
        const alertId = e.target.dataset.alertId;
        toggleAlert(alertId);
      });
    });
    
    // Clic sur le contenu pour √©diter
    alertList.querySelectorAll('.alert-item-content').forEach(content => {
      content.addEventListener('click', (e) => {
        e.stopPropagation();
        const alertId = content.dataset.alertId;
        editAlert(alertId);
      });
      content.style.cursor = 'pointer';
    });
    
    alertList.querySelectorAll('.btn-delete-alert').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const alertId = e.target.dataset.alertId;
        deleteAlert(alertId);
      });
    });
  }
  
  // √âtat du filtre par alertes
  let isAlertFilterActive = false;
  const ALERT_FILTER_STORAGE_KEY = 'vinted_alert_filter_active';
  
  // Charger l'√©tat du filtre par alertes depuis le storage
  async function loadAlertFilterState() {
    try {
      const result = await chrome.storage.local.get(ALERT_FILTER_STORAGE_KEY);
      isAlertFilterActive = result[ALERT_FILTER_STORAGE_KEY] || false;
      // Mettre √† jour le bouton si disponible
      updateAlertFilterButton();
      // R√©appliquer le filtre si actif
      if (isAlertFilterActive) {
        applyAlertFilter();
      }
    } catch (error) {
      console.error("[Alert Filter] Erreur lors du chargement:", error);
      isAlertFilterActive = false;
    }
  }
  
  // Mettre √† jour l'√©tat visuel du bouton de filtre
  function updateAlertFilterButton() {
    const filterBtn = document.getElementById('filter-by-alerts');
    if (!filterBtn) return;
    
    if (isAlertFilterActive) {
      filterBtn.textContent = 'Tout';
      filterBtn.classList.add('active');
      filterBtn.title = 'Afficher tous les items';
    } else {
      filterBtn.textContent = 'Filtrer';
      filterBtn.classList.remove('active');
      filterBtn.title = 'Afficher uniquement les items avec mots-cl√©s des alertes';
    }
  }
  
  // Sauvegarder l'√©tat du filtre par alertes
  async function saveAlertFilterState() {
    try {
      await chrome.storage.local.set({ [ALERT_FILTER_STORAGE_KEY]: isAlertFilterActive });
    } catch (error) {
      console.error("[Alert Filter] Erreur lors de la sauvegarde:", error);
    }
  }
  
  // Toggle du filtre par alertes
  async function toggleAlertFilter() {
    const filterBtn = document.getElementById('filter-by-alerts');
    if (!filterBtn) return;
    
    isAlertFilterActive = !isAlertFilterActive;
    await saveAlertFilterState();
    
    if (isAlertFilterActive) {
      applyAlertFilter();
    } else {
      removeAlertFilter();
    }
    
    // Mettre √† jour l'√©tat du bouton
    updateAlertFilterButton();
  }
  
  // Appliquer le filtre par alertes
  function applyAlertFilter() {
    // R√©cup√©rer tous les mots-cl√©s de toutes les alertes
    const allKeywords = [];
    state.alerts.forEach(alert => {
      if (alert.enabled && alert.keywords) {
        allKeywords.push(...alert.keywords);
      }
    });
    
    if (allKeywords.length === 0) {
      alert('Aucun mot-cl√© d√©fini dans les alertes actives.');
      toggleAlertFilter(); // D√©sactiver le filtre
      return;
    }
    
    // Filtrer les items affich√©s
    const itemCards = document.querySelectorAll('.item-card');
    itemCards.forEach(card => {
      const titleElement = card.querySelector('.item-title');
      if (titleElement) {
        const title = titleElement.textContent.toLowerCase();
        const matchesKeyword = allKeywords.some(keyword => 
          title.includes(keyword.toLowerCase())
        );
        
        if (matchesKeyword) {
          card.style.display = '';
        } else {
          card.style.display = 'none';
        }
      }
    });
  }
  
  // Retirer le filtre par alertes
  function removeAlertFilter() {
    const itemCards = document.querySelectorAll('.item-card');
    itemCards.forEach(card => {
      card.style.display = '';
    });
  }
  
  // Cr√©er l'interface du syst√®me d'alertes
  let alertSystemRetries = 0;
  const MAX_ALERT_RETRIES = 10;
  
  function createAlertSystem() {
    const sidebar = document.getElementById('sidebar');
    
    if (!sidebar) {
      alertSystemRetries++;
      if (alertSystemRetries < MAX_ALERT_RETRIES) {
        console.warn(`[Alert System] Sidebar non trouv√©e (tentative ${alertSystemRetries}/${MAX_ALERT_RETRIES}), r√©essai dans 500ms`);
        setTimeout(createAlertSystem, 500);
      } else {
        console.error("[Alert System] Sidebar introuvable apr√®s plusieurs tentatives, abandon");
      }
      return;
    }
    
    if (document.getElementById('alert-system')) {
      console.log("[Alert System] Interface d√©j√† cr√©√©e");
      return;
    }
    
    try {
      const alertSystem = document.createElement('div');
      alertSystem.id = 'alert-system';
      alertSystem.className = 'alert-system';
      alertSystem.style.display = 'none'; // Masqu√© par d√©faut
      alertSystem.innerHTML = `
        <div class="alert-system-header">
          <h3 class="alert-system-title">Alertes Prix</h3>
          <div class="alert-buttons">
            <button id="filter-by-alerts" class="btn-filter-alerts" title="Afficher uniquement les items avec mots-cl√©s des alertes">Filtrer</button>
            <button id="create-alert" class="btn-create-alert" title="Cr√©er une alerte">Cr√©er</button>
          </div>
        </div>
        <div id="alert-list" class="alert-list">
          <p class="alert-empty">Aucune alerte cr√©√©e</p>
        </div>
      `;
      
      // Ins√©rer dans le conteneur sticky apr√®s le filter-manager
      const stickyContainer = document.getElementById('sidebar-sticky-container');
      if (stickyContainer) {
        stickyContainer.appendChild(alertSystem);
      } else {
        // Fallback si le sticky container n'existe pas
        const filterManager = document.getElementById('filter-manager');
        if (filterManager && filterManager.parentNode) {
          filterManager.parentNode.appendChild(alertSystem);
        } else {
          sidebar.insertBefore(alertSystem, sidebar.firstChild);
        }
      }
      
      document.getElementById('create-alert').addEventListener('click', createAlert);
      document.getElementById('filter-by-alerts').addEventListener('click', toggleAlertFilter);
      loadAlerts().then(() => renderAlertList());
      
      console.log("[Alert System] Interface cr√©√©e avec succ√®s");
      alertSystemRetries = 0;
    } catch (error) {
      console.error("[Alert System] Erreur lors de la cr√©ation:", error);
      alertSystemRetries++;
      if (alertSystemRetries < MAX_ALERT_RETRIES) {
        setTimeout(createAlertSystem, 500);
      }
    }
  }

  // ==========================================
  // pickupPoints.js
  // ==========================================
  
  // ==================== PICKUP POINTS SYSTEM ====================
  
  const PICKUP_POINTS_STORAGE_KEY = 'pickupPoints';
  let pickupPointsRetries = 0;
  const MAX_PICKUP_RETRIES = 10;
  
  async function loadPickupPoints() {
    return new Promise((resolve) => {
      chrome.storage.local.get([PICKUP_POINTS_STORAGE_KEY], (result) => {
        const points = result[PICKUP_POINTS_STORAGE_KEY] || [];
        resolve(points);
      });
    });
  }
  
  function savePickupPoints(points) {
    chrome.storage.local.set({ [PICKUP_POINTS_STORAGE_KEY]: points }, () => {
      console.log('[Pickup Points] Points relais sauvegard√©s:', points);
    });
  }
  
  function createPickupPoint() {
    const name = prompt('Nom du point relais (ex: LOCKER 24/7 HYPER U ROMANS SUR):');
    if (!name || name.trim() === '') return;
    
    loadPickupPoints().then(points => {
      if (points.length >= 3) {
        alert('Vous ne pouvez enregistrer que 3 points relais maximum');
        return;
      }
      
      const newPoint = {
        id: Date.now().toString(),
        name: name.trim()
      };
      
      points.push(newPoint);
      savePickupPoints(points);
      renderPickupPointsList();
    });
  }
  
  function deletePickupPoint(pointId) {
    if (!confirm('Supprimer ce point relais ?')) return;
    
    loadPickupPoints().then(points => {
      const filtered = points.filter(p => p.id !== pointId);
      savePickupPoints(filtered);
      renderPickupPointsList();
    });
  }
  
  function movePickupPointUp(pointId) {
    loadPickupPoints().then(points => {
      const index = points.findIndex(p => p.id === pointId);
      if (index > 0) {
        [points[index - 1], points[index]] = [points[index], points[index - 1]];
        savePickupPoints(points);
        renderPickupPointsList();
      }
    });
  }
  
  function movePickupPointDown(pointId) {
    loadPickupPoints().then(points => {
      const index = points.findIndex(p => p.id === pointId);
      if (index < points.length - 1) {
        [points[index], points[index + 1]] = [points[index + 1], points[index]];
        savePickupPoints(points);
        renderPickupPointsList();
      }
    });
  }
  
  function renderPickupPointsList() {
    const list = document.getElementById('pickup-points-list');
    if (!list) return;
    
    // Mettre √† jour le compteur
    updatePickupCount();
    
    loadPickupPoints().then(points => {
      if (points.length === 0) {
        list.innerHTML = '<p class="pickup-empty">Aucun point relais configur√©</p>';
        return;
      }
      
      list.innerHTML = points.map((point, index) => `
        <div class="pickup-point-item" data-point-id="${point.id}">
          <div class="pickup-point-priority">${index + 1}</div>
          <div class="pickup-point-content">
            <div class="pickup-point-name">${escapeHtml(point.name)}</div>
          </div>
          <div class="pickup-point-actions">
            ${index > 0 ? `<button class="btn-move-up" data-point-id="${point.id}" title="Monter">‚Üë</button>` : '<span class="btn-placeholder"></span>'}
            ${index < points.length - 1 ? `<button class="btn-move-down" data-point-id="${point.id}" title="Descendre">‚Üì</button>` : '<span class="btn-placeholder"></span>'}
            <button class="btn-delete-pickup" data-point-id="${point.id}" title="Supprimer">‚úñ</button>
          </div>
        </div>
      `).join('');
      
      // Event listeners
      list.querySelectorAll('.btn-move-up').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          movePickupPointUp(btn.dataset.pointId);
        });
      });
      
      list.querySelectorAll('.btn-move-down').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          movePickupPointDown(btn.dataset.pointId);
        });
      });
      
      list.querySelectorAll('.btn-delete-pickup').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          deletePickupPoint(btn.dataset.pointId);
        });
      });
    });
  }
  
  function createPickupPointsSystem() {
    const sidebar = document.getElementById('sidebar');
    
    if (!sidebar) {
      pickupPointsRetries++;
      if (pickupPointsRetries < MAX_PICKUP_RETRIES) {
        console.warn(`[Pickup Points] Sidebar non trouv√©e (tentative ${pickupPointsRetries}/${MAX_PICKUP_RETRIES}), r√©essai dans 500ms`);
        setTimeout(createPickupPointsSystem, 500);
      } else {
        console.error("[Pickup Points] Sidebar introuvable apr√®s plusieurs tentatives, abandon");
      }
      return;
    }
    
    if (document.getElementById('pickup-points-system')) {
      console.log("[Pickup Points] Interface d√©j√† cr√©√©e");
      return;
    }
    
    try {
      const pickupSystem = document.createElement('div');
      pickupSystem.id = 'pickup-points-system';
      pickupSystem.className = 'pickup-points-system';
      pickupSystem.style.display = 'none'; // Masqu√© par d√©faut
      pickupSystem.innerHTML = `
        <div class="pickup-system-header">
          <h3 class="pickup-system-title">Points Relais</h3>
          <button id="create-pickup-point" class="btn-create-pickup" title="Ajouter un point relais">Ajouter</button>
        </div>
        <div id="pickup-points-list" class="pickup-points-list">
          <p class="pickup-empty">Aucun point relais configur√©</p>
        </div>
        <div class="pickup-system-info">
          <p class="pickup-info-text">
            <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="display: inline-block; vertical-align: middle; margin-right: 4px;">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
            </svg>
            Priorit√©: 1 > 2 > 3
          </p>
        </div>
      `;
      
      // Ins√©rer dans le conteneur sticky avec les autres sections
      const stickyContainer = document.getElementById('sidebar-sticky-container');
      if (stickyContainer) {
        // Ins√©rer apr√®s les alertes
        const alertSystem = document.getElementById('alert-system');
        if (alertSystem && alertSystem.parentNode === stickyContainer) {
          stickyContainer.insertBefore(pickupSystem, alertSystem.nextSibling);
        } else {
          stickyContainer.appendChild(pickupSystem);
        }
      } else {
        // Fallback si le sticky container n'existe pas encore
        const alertSystem = document.getElementById('alert-system');
        if (alertSystem && alertSystem.parentNode) {
          alertSystem.parentNode.insertBefore(pickupSystem, alertSystem.nextSibling);
        } else {
          sidebar.insertBefore(pickupSystem, sidebar.firstChild);
        }
      }
      
      document.getElementById('create-pickup-point').addEventListener('click', createPickupPoint);
      renderPickupPointsList();
      
      console.log("[Pickup Points] Interface cr√©√©e avec succ√®s");
    } catch (error) {
      console.error("[Pickup Points] Erreur lors de la cr√©ation:", error);
      pickupPointsRetries++;
      if (pickupPointsRetries < MAX_PICKUP_RETRIES) {
        setTimeout(createPickupPointsSystem, 500);
      }
    }
  }

  // ==========================================
  // ui.js
  // ==========================================
  
  // ==================== UI ====================
  let toggleButtonRetries = 0;
  const MAX_TOGGLE_RETRIES = 10;
  
  function createToggleButton() {
    if (document.getElementById('toggle-monitor')) {
      console.log("[Vinted Monitor] Bouton toggle d√©j√† cr√©√©");
      return;
    }
  
    const navbarRight = document.querySelector('nav .u-position-relative') || document.querySelector('.u-position-relative');
    
    if (!navbarRight) {
      toggleButtonRetries++;
      if (toggleButtonRetries < MAX_TOGGLE_RETRIES) {
        console.warn(`[Vinted Monitor] √âl√©ment de langue non trouv√© (tentative ${toggleButtonRetries}/${MAX_TOGGLE_RETRIES}), r√©essai dans 500ms`);
        setTimeout(createToggleButton, 500);
      } else {
        console.error("[Vinted Monitor] √âl√©ment de langue introuvable apr√®s plusieurs tentatives, abandon");
      }
      return;
    }
  
    const btnWrapper = document.createElement("div");
    btnWrapper.style.cssText = `display: inline-flex; align-items: center; gap: 8px; margin-left: auto; flex-wrap: nowrap;`;
    
    // Affichage du solde du portefeuille
    const walletDisplay = document.createElement("div");
    walletDisplay.id = "vinted-wallet-balance";
    walletDisplay.className = "vinted-wallet-balance";
    walletDisplay.textContent = "Chargement...";
    walletDisplay.title = "Solde du portefeuille Vinted";
    // Les styles sont maintenant dans styles.css
    
    // Bouton Buy Toggle
    const buyButtonToggle = document.createElement("button");
    buyButtonToggle.id = "buy-button-toggle";
    buyButtonToggle.className = "btn-buy-toggle";
    buyButtonToggle.innerHTML = state.buyButtonEnabled 
      ? '<svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>'
      : '<svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>';
    buyButtonToggle.title = state.buyButtonEnabled ? "D√©sactiver le bouton Buy" : "Activer le bouton Buy";
    buyButtonToggle.style.cssText = `padding: 8px 12px; background: #6b7280; color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);`;
    buyButtonToggle.addEventListener("click", toggleBuyButton);
    buyButtonToggle.addEventListener("mouseenter", () => {
      buyButtonToggle.style.background = "#4b5563";
      buyButtonToggle.style.transform = "translateY(-1px)";
      buyButtonToggle.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.15)";
    });
    buyButtonToggle.addEventListener("mouseleave", () => {
      buyButtonToggle.style.background = "#6b7280";
      buyButtonToggle.style.transform = "translateY(0)";
      buyButtonToggle.style.boxShadow = "0 2px 4px rgba(0, 0, 0, 0.1)";
    });
    
    // Bouton Dark Mode
    const darkModeBtn = document.createElement("button");
    darkModeBtn.id = "dark-mode-toggle";
    darkModeBtn.className = "btn-dark-mode";
    darkModeBtn.textContent = state.darkMode ? "‚òÄÔ∏è" : "üåô";
    darkModeBtn.title = state.darkMode ? "Mode clair" : "Mode sombre";
    darkModeBtn.style.cssText = `padding: 8px 12px; background: #6b7280; color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);`;
    darkModeBtn.addEventListener("click", toggleDarkMode);
    darkModeBtn.addEventListener("mouseenter", () => {
      darkModeBtn.style.background = "#4b5563";
      darkModeBtn.style.transform = "translateY(-1px)";
      darkModeBtn.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.15)";
    });
    darkModeBtn.addEventListener("mouseleave", () => {
      darkModeBtn.style.background = "#6b7280";
      darkModeBtn.style.transform = "translateY(0)";
      darkModeBtn.style.boxShadow = "0 2px 4px rgba(0, 0, 0, 0.1)";
    });
    
    // Bouton Monitor
    const toggleBtn = document.createElement("button");
    toggleBtn.id = "toggle-monitor";
    toggleBtn.className = "btn-monitor-toggle";
    toggleBtn.textContent = "‚ñ∂";
    toggleBtn.style.cssText = `padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);`;
    
    btnWrapper.appendChild(walletDisplay);
    btnWrapper.appendChild(buyButtonToggle);
    btnWrapper.appendChild(darkModeBtn);
    btnWrapper.appendChild(toggleBtn);
    
    // Ins√©rer le btnWrapper √† droite de la navbar (dans navbarRight ou apr√®s)
    if (navbarRight) {
      // Essayer d'ins√©rer dans navbarRight s'il a un conteneur flex
      const navbarParent = navbarRight.parentElement;
      if (navbarParent && (navbarParent.classList.contains('u-flexbox') || getComputedStyle(navbarParent).display === 'flex')) {
        navbarParent.appendChild(btnWrapper);
      } else {
        // Sinon ins√©rer apr√®s navbarRight
        navbarRight.parentNode.insertBefore(btnWrapper, navbarRight.nextSibling);
      }
    }
    
    // Charger le solde du portefeuille
    loadWalletBalance();
    
    // Initialiser l'affichage du nombre d'offres restantes imm√©diatement
    if (typeof initOfferCount === 'function') {
      initOfferCount();
    }
    
    // Cr√©er le widget de notifications √† c√¥t√© du wallet
    setTimeout(() => {
      createNotificationsWidget();
    }, 1500);
    
    // Cr√©er le bouton de param√®tres
    setTimeout(() => {
      if (typeof createSettingsButton === 'function') {
        createSettingsButton();
      }
    }, 2000);
    
    console.log("[Vinted Monitor] Bouton toggle cr√©√© avec succ√®s");
    toggleButtonRetries = 0;
    
    toggleBtn.addEventListener("click", toggleMonitor);
    
    toggleBtn.addEventListener("mouseenter", () => {
      toggleBtn.style.background = "#2563eb";
      toggleBtn.style.transform = "translateY(-1px)";
      toggleBtn.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.15)";
    });
    toggleBtn.addEventListener("mouseleave", () => {
      toggleBtn.style.transform = "translateY(0)";
      toggleBtn.style.boxShadow = "0 2px 4px rgba(0, 0, 0, 0.1)";
      if (!state.isPolling) {
        toggleBtn.style.background = "#3b82f6";
      } else {
        toggleBtn.style.background = "#dc2626";
      }
    });
  }
  
  function createMonitorUI() {
    const container = document.createElement("div");
    container.id = "vinted-monitor-container";
    container.innerHTML = `<div id="items-container" class="items-grid"></div>`;
  
    const navCategories = document.querySelector('ul.nav.nav-detailed.nav-page-categories[data-testid="sub-catalog-navigation-links"]');
    
    if (navCategories && navCategories.parentNode) {
      navCategories.parentNode.insertBefore(container, navCategories.nextSibling);
    } else {
      const body = document.body;
      if (body.firstChild) {
        body.insertBefore(container, body.firstChild);
      } else {
        body.appendChild(container);
      }
    }
  
    createToggleButton();
    createFilterManager();
    createAlertSystem();
    createPickupPointsSystem();
    // Cr√©er le manager de commandes et de messages apr√®s un d√©lai pour s'assurer que le manager de messages est cr√©√©
    setTimeout(() => {
      createOrdersManager();
      createWardrobeManager();
      createMessagesListManager();
      // Cr√©er les tabs apr√®s que tous les managers soient cr√©√©s
      setTimeout(() => {
        createSidebarTabs();
        // Charger les compteurs m√™me si on n'est pas sur les onglets
        // Ne pas appeler updateMessagesCountInTab() sans param√®tre car cela ferait une requ√™te
        // Le compteur sera mis √† jour par loadMessages quand les donn√©es seront disponibles
        setTimeout(() => {
          updateOrdersCount();
          refreshWardrobeCount(); // Mettre √† jour le compteur du wardrobe
        }, 1000);
      }, 500);
    }, 1500);
    // Initialiser les intervalles depuis les settings
    setTimeout(async () => {
      if (typeof initIntervals === 'function') {
        await initIntervals();
      }
    }, 500);
    
    // D√©marrer le monitor imm√©diatement pour charger les articles d√®s le lancement
    setTimeout(() => startMonitor(), 100);
    
    // Arr√™ter le rafra√Æchissement automatique des messages quand on quitte la page
    window.addEventListener('beforeunload', () => {
      stopMessagesAutoRefresh();
    });
  }

  // ==========================================
  // init.js
  // ==========================================
  
  // ==================== INIT ====================
  function isOnCatalogPage() {
    return window.location.pathname.startsWith('/catalog');
  }
  
  function isAlreadyInitialized() {
    return document.getElementById('vinted-monitor-container') !== null || 
           document.getElementById('toggle-monitor') !== null;
  }
  
  function init() {
    console.log("[Vinted Monitor] Extension charg√©e");
  
    // Charger le dark mode et l'√©tat du bouton buy en premier
    // Note: loadDarkMode() g√®re d√©j√† l'initialisation, pas besoin de dupliquer
    loadDarkMode();
    loadBuyButtonState();
    loadAlertFilterState();
  
    if (!isOnCatalogPage()) {
      console.log("[Vinted Monitor] Pas sur une page catalog, extension d√©sactiv√©e");
      return;
    }
  
    if (isAlreadyInitialized()) {
      console.log("[Vinted Monitor] Extension d√©j√† initialis√©e");
      return;
    }
  
    const tryCreateUI = () => {
      try {
        createMonitorUI();
        observeUrlChanges();
        console.log("[Vinted Monitor] UI cr√©√©e avec succ√®s");
      } catch (error) {
        console.error("[Vinted Monitor] Erreur lors de la cr√©ation de l'UI:", error);
        setTimeout(tryCreateUI, 1000);
      }
    };
  
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => {
        setTimeout(tryCreateUI, 1000);
      });
    } else if (document.readyState === "interactive") {
      setTimeout(tryCreateUI, 1500);
    } else if (document.readyState === "complete") {
      setTimeout(tryCreateUI, 1000);
    } else {
      setTimeout(tryCreateUI, 1000);
    }
  }
  
  init();

})();
